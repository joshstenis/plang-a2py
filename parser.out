Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt_list SEMICOLON
Rule 2     stmt_list -> stmt_list SEMICOLON stmt
Rule 3     stmt_list -> stmt
Rule 4     stmt -> assignment
Rule 5     stmt -> read
Rule 6     stmt -> write
Rule 7     stmt -> while
Rule 8     stmt -> repeat
Rule 9     stmt -> block
Rule 10    stmt -> foreach
Rule 11    stmt -> if_stmt
Rule 12    assignment -> varref ASSIGN l_expr
Rule 13    read -> READ varlist
Rule 14    write -> WRITE expr_list
Rule 15    while -> WHILE l_expr block
Rule 16    repeat -> REPEAT stmt_list UNTIL l_expr
Rule 17    block -> BEGIN stmt_list END
Rule 18    foreach -> FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
Rule 19    if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt
Rule 20    else_stmt -> <empty>
Rule 21    else_stmt -> ELSE stmt
Rule 22    a_expr -> a_expr ADD a_term
Rule 23    a_expr -> a_expr SUB a_term
Rule 24    a_expr -> a_term
Rule 25    a_term -> a_term MUL a_fact
Rule 26    a_term -> a_term DIV a_fact
Rule 27    a_term -> a_fact
Rule 28    a_fact -> varref
Rule 29    a_fact -> NUM
Rule 30    a_fact -> LITERAL_STR
Rule 31    a_fact -> SUB a_fact
Rule 32    a_fact -> LPAREN a_expr RPAREN
Rule 33    varref -> ID
Rule 34    varref -> varref LBRACK a_expr RBRACK
Rule 35    l_expr -> l_expr AND l_term
Rule 36    l_expr -> l_term
Rule 37    l_term -> l_term OR l_fact
Rule 38    l_term -> l_fact
Rule 39    l_fact -> l_fact oprel a_expr
Rule 40    l_fact -> a_expr
Rule 41    l_fact -> LPAREN l_expr RPAREN
Rule 42    oprel -> LT
Rule 43    oprel -> GT
Rule 44    oprel -> LEQ
Rule 45    oprel -> GEQ
Rule 46    oprel -> EQ
Rule 47    oprel -> NEQ
Rule 48    varlist -> varref
Rule 49    varlist -> varref COMMA_DELIM varlist
Rule 50    expr_list -> a_expr
Rule 51    expr_list -> expr_list COMMA_DELIM a_expr

Terminals, with rules where they appear

ADD                  : 22
AND                  : 35
ASSIGN               : 12
BEGIN                : 17
COLON                : 18
COMMA_DELIM          : 49 51
COMMENT              : 
DIV                  : 26
ELSE                 : 19 21
END                  : 17
EQ                   : 46
FOREACH              : 18
GEQ                  : 45
GT                   : 43
ID                   : 18 33
IF                   : 19
IN                   : 18
LBRACK               : 34
LEQ                  : 44
LITERAL_STR          : 30
LPAREN               : 18 32 41
LT                   : 42
MUL                  : 25
NEQ                  : 47
NUM                  : 29
OR                   : 37
RBRACK               : 34
READ                 : 13
REPEAT               : 16
RPAREN               : 18 32 41
SEMICOLON            : 1 2
SUB                  : 23 31
THEN                 : 19
UNTIL                : 16
WHILE                : 15
WRITE                : 14
error                : 

Nonterminals, with rules where they appear

a_expr               : 22 23 32 34 39 40 50 51
a_fact               : 18 18 25 26 27 31
a_term               : 22 23 24 25 26
assignment           : 4
block                : 9 15
else_stmt            : 19
expr_list            : 14 51
foreach              : 10
if_stmt              : 11
l_expr               : 12 15 16 19 35 41
l_fact               : 37 38 39
l_term               : 35 36 37
oprel                : 39
program              : 0
read                 : 5
repeat               : 8
stmt                 : 2 3 18 21
stmt_list            : 1 2 16 17 19
varlist              : 13 49
varref               : 12 28 34 48 49
while                : 7
write                : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt_list SEMICOLON
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt_list . SEMICOLON
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    SEMICOLON       shift and go to state 21


state 3

    (3) stmt_list -> stmt .

    SEMICOLON       reduce using rule 3 (stmt_list -> stmt .)
    UNTIL           reduce using rule 3 (stmt_list -> stmt .)
    END             reduce using rule 3 (stmt_list -> stmt .)
    ELSE            reduce using rule 3 (stmt_list -> stmt .)


state 4

    (4) stmt -> assignment .

    SEMICOLON       reduce using rule 4 (stmt -> assignment .)
    UNTIL           reduce using rule 4 (stmt -> assignment .)
    END             reduce using rule 4 (stmt -> assignment .)
    ELSE            reduce using rule 4 (stmt -> assignment .)


state 5

    (5) stmt -> read .

    SEMICOLON       reduce using rule 5 (stmt -> read .)
    UNTIL           reduce using rule 5 (stmt -> read .)
    END             reduce using rule 5 (stmt -> read .)
    ELSE            reduce using rule 5 (stmt -> read .)


state 6

    (6) stmt -> write .

    SEMICOLON       reduce using rule 6 (stmt -> write .)
    UNTIL           reduce using rule 6 (stmt -> write .)
    END             reduce using rule 6 (stmt -> write .)
    ELSE            reduce using rule 6 (stmt -> write .)


state 7

    (7) stmt -> while .

    SEMICOLON       reduce using rule 7 (stmt -> while .)
    UNTIL           reduce using rule 7 (stmt -> while .)
    END             reduce using rule 7 (stmt -> while .)
    ELSE            reduce using rule 7 (stmt -> while .)


state 8

    (8) stmt -> repeat .

    SEMICOLON       reduce using rule 8 (stmt -> repeat .)
    UNTIL           reduce using rule 8 (stmt -> repeat .)
    END             reduce using rule 8 (stmt -> repeat .)
    ELSE            reduce using rule 8 (stmt -> repeat .)


state 9

    (9) stmt -> block .

    SEMICOLON       reduce using rule 9 (stmt -> block .)
    UNTIL           reduce using rule 9 (stmt -> block .)
    END             reduce using rule 9 (stmt -> block .)
    ELSE            reduce using rule 9 (stmt -> block .)


state 10

    (10) stmt -> foreach .

    SEMICOLON       reduce using rule 10 (stmt -> foreach .)
    UNTIL           reduce using rule 10 (stmt -> foreach .)
    END             reduce using rule 10 (stmt -> foreach .)
    ELSE            reduce using rule 10 (stmt -> foreach .)


state 11

    (11) stmt -> if_stmt .

    SEMICOLON       reduce using rule 11 (stmt -> if_stmt .)
    UNTIL           reduce using rule 11 (stmt -> if_stmt .)
    END             reduce using rule 11 (stmt -> if_stmt .)
    ELSE            reduce using rule 11 (stmt -> if_stmt .)


state 12

    (12) assignment -> varref . ASSIGN l_expr
    (34) varref -> varref . LBRACK a_expr RBRACK

    ASSIGN          shift and go to state 22
    LBRACK          shift and go to state 23


state 13

    (13) read -> READ . varlist
    (48) varlist -> . varref
    (49) varlist -> . varref COMMA_DELIM varlist
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    ID              shift and go to state 19

    varlist                        shift and go to state 24
    varref                         shift and go to state 25

state 14

    (14) write -> WRITE . expr_list
    (50) expr_list -> . a_expr
    (51) expr_list -> . expr_list COMMA_DELIM a_expr
    (22) a_expr -> . a_expr ADD a_term
    (23) a_expr -> . a_expr SUB a_term
    (24) a_expr -> . a_term
    (25) a_term -> . a_term MUL a_fact
    (26) a_term -> . a_term DIV a_fact
    (27) a_term -> . a_fact
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    expr_list                      shift and go to state 26
    a_expr                         shift and go to state 27
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 15

    (15) while -> WHILE . l_expr block
    (35) l_expr -> . l_expr AND l_term
    (36) l_expr -> . l_term
    (37) l_term -> . l_term OR l_fact
    (38) l_term -> . l_fact
    (39) l_fact -> . l_fact oprel a_expr
    (40) l_fact -> . a_expr
    (41) l_fact -> . LPAREN l_expr RPAREN
    (22) a_expr -> . a_expr ADD a_term
    (23) a_expr -> . a_expr SUB a_term
    (24) a_expr -> . a_term
    (25) a_term -> . a_term MUL a_fact
    (26) a_term -> . a_term DIV a_fact
    (27) a_term -> . a_fact
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 39
    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    ID              shift and go to state 19

    l_expr                         shift and go to state 35
    l_term                         shift and go to state 36
    l_fact                         shift and go to state 37
    a_expr                         shift and go to state 38
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 16

    (16) repeat -> REPEAT . stmt_list UNTIL l_expr
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt_list                      shift and go to state 40
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 17

    (17) block -> BEGIN . stmt_list END
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt_list                      shift and go to state 41
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 18

    (18) foreach -> FOREACH . ID IN LPAREN a_fact COLON a_fact RPAREN stmt

    ID              shift and go to state 42


state 19

    (33) varref -> ID .

    ASSIGN          reduce using rule 33 (varref -> ID .)
    LBRACK          reduce using rule 33 (varref -> ID .)
    COMMA_DELIM     reduce using rule 33 (varref -> ID .)
    SEMICOLON       reduce using rule 33 (varref -> ID .)
    UNTIL           reduce using rule 33 (varref -> ID .)
    END             reduce using rule 33 (varref -> ID .)
    ELSE            reduce using rule 33 (varref -> ID .)
    MUL             reduce using rule 33 (varref -> ID .)
    DIV             reduce using rule 33 (varref -> ID .)
    ADD             reduce using rule 33 (varref -> ID .)
    SUB             reduce using rule 33 (varref -> ID .)
    LT              reduce using rule 33 (varref -> ID .)
    GT              reduce using rule 33 (varref -> ID .)
    LEQ             reduce using rule 33 (varref -> ID .)
    GEQ             reduce using rule 33 (varref -> ID .)
    EQ              reduce using rule 33 (varref -> ID .)
    NEQ             reduce using rule 33 (varref -> ID .)
    OR              reduce using rule 33 (varref -> ID .)
    AND             reduce using rule 33 (varref -> ID .)
    BEGIN           reduce using rule 33 (varref -> ID .)
    THEN            reduce using rule 33 (varref -> ID .)
    RBRACK          reduce using rule 33 (varref -> ID .)
    RPAREN          reduce using rule 33 (varref -> ID .)
    COLON           reduce using rule 33 (varref -> ID .)


state 20

    (19) if_stmt -> IF . l_expr THEN stmt_list ELSE else_stmt
    (35) l_expr -> . l_expr AND l_term
    (36) l_expr -> . l_term
    (37) l_term -> . l_term OR l_fact
    (38) l_term -> . l_fact
    (39) l_fact -> . l_fact oprel a_expr
    (40) l_fact -> . a_expr
    (41) l_fact -> . LPAREN l_expr RPAREN
    (22) a_expr -> . a_expr ADD a_term
    (23) a_expr -> . a_expr SUB a_term
    (24) a_expr -> . a_term
    (25) a_term -> . a_term MUL a_fact
    (26) a_term -> . a_term DIV a_fact
    (27) a_term -> . a_fact
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 39
    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    ID              shift and go to state 19

    l_expr                         shift and go to state 43
    l_term                         shift and go to state 36
    l_fact                         shift and go to state 37
    a_expr                         shift and go to state 38
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 21

    (1) program -> stmt_list SEMICOLON .
    (2) stmt_list -> stmt_list SEMICOLON . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    $end            reduce using rule 1 (program -> stmt_list SEMICOLON .)
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt                           shift and go to state 44
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 22

    (12) assignment -> varref ASSIGN . l_expr
    (35) l_expr -> . l_expr AND l_term
    (36) l_expr -> . l_term
    (37) l_term -> . l_term OR l_fact
    (38) l_term -> . l_fact
    (39) l_fact -> . l_fact oprel a_expr
    (40) l_fact -> . a_expr
    (41) l_fact -> . LPAREN l_expr RPAREN
    (22) a_expr -> . a_expr ADD a_term
    (23) a_expr -> . a_expr SUB a_term
    (24) a_expr -> . a_term
    (25) a_term -> . a_term MUL a_fact
    (26) a_term -> . a_term DIV a_fact
    (27) a_term -> . a_fact
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 39
    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    ID              shift and go to state 19

    varref                         shift and go to state 31
    l_expr                         shift and go to state 45
    l_term                         shift and go to state 36
    l_fact                         shift and go to state 37
    a_expr                         shift and go to state 38
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30

state 23

    (34) varref -> varref LBRACK . a_expr RBRACK
    (22) a_expr -> . a_expr ADD a_term
    (23) a_expr -> . a_expr SUB a_term
    (24) a_expr -> . a_term
    (25) a_term -> . a_term MUL a_fact
    (26) a_term -> . a_term DIV a_fact
    (27) a_term -> . a_fact
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    varref                         shift and go to state 31
    a_expr                         shift and go to state 46
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30

state 24

    (13) read -> READ varlist .

    SEMICOLON       reduce using rule 13 (read -> READ varlist .)
    UNTIL           reduce using rule 13 (read -> READ varlist .)
    END             reduce using rule 13 (read -> READ varlist .)
    ELSE            reduce using rule 13 (read -> READ varlist .)


state 25

    (48) varlist -> varref .
    (49) varlist -> varref . COMMA_DELIM varlist
    (34) varref -> varref . LBRACK a_expr RBRACK

    SEMICOLON       reduce using rule 48 (varlist -> varref .)
    UNTIL           reduce using rule 48 (varlist -> varref .)
    END             reduce using rule 48 (varlist -> varref .)
    ELSE            reduce using rule 48 (varlist -> varref .)
    COMMA_DELIM     shift and go to state 47
    LBRACK          shift and go to state 23


state 26

    (14) write -> WRITE expr_list .
    (51) expr_list -> expr_list . COMMA_DELIM a_expr

    SEMICOLON       reduce using rule 14 (write -> WRITE expr_list .)
    UNTIL           reduce using rule 14 (write -> WRITE expr_list .)
    END             reduce using rule 14 (write -> WRITE expr_list .)
    ELSE            reduce using rule 14 (write -> WRITE expr_list .)
    COMMA_DELIM     shift and go to state 48


state 27

    (50) expr_list -> a_expr .
    (22) a_expr -> a_expr . ADD a_term
    (23) a_expr -> a_expr . SUB a_term

    COMMA_DELIM     reduce using rule 50 (expr_list -> a_expr .)
    SEMICOLON       reduce using rule 50 (expr_list -> a_expr .)
    UNTIL           reduce using rule 50 (expr_list -> a_expr .)
    END             reduce using rule 50 (expr_list -> a_expr .)
    ELSE            reduce using rule 50 (expr_list -> a_expr .)
    ADD             shift and go to state 49
    SUB             shift and go to state 50


state 28

    (24) a_expr -> a_term .
    (25) a_term -> a_term . MUL a_fact
    (26) a_term -> a_term . DIV a_fact

    ADD             reduce using rule 24 (a_expr -> a_term .)
    SUB             reduce using rule 24 (a_expr -> a_term .)
    COMMA_DELIM     reduce using rule 24 (a_expr -> a_term .)
    SEMICOLON       reduce using rule 24 (a_expr -> a_term .)
    UNTIL           reduce using rule 24 (a_expr -> a_term .)
    END             reduce using rule 24 (a_expr -> a_term .)
    ELSE            reduce using rule 24 (a_expr -> a_term .)
    LT              reduce using rule 24 (a_expr -> a_term .)
    GT              reduce using rule 24 (a_expr -> a_term .)
    LEQ             reduce using rule 24 (a_expr -> a_term .)
    GEQ             reduce using rule 24 (a_expr -> a_term .)
    EQ              reduce using rule 24 (a_expr -> a_term .)
    NEQ             reduce using rule 24 (a_expr -> a_term .)
    OR              reduce using rule 24 (a_expr -> a_term .)
    AND             reduce using rule 24 (a_expr -> a_term .)
    BEGIN           reduce using rule 24 (a_expr -> a_term .)
    THEN            reduce using rule 24 (a_expr -> a_term .)
    RBRACK          reduce using rule 24 (a_expr -> a_term .)
    RPAREN          reduce using rule 24 (a_expr -> a_term .)
    MUL             shift and go to state 51
    DIV             shift and go to state 52


state 29

    (31) a_fact -> SUB . a_fact
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_fact                         shift and go to state 53
    varref                         shift and go to state 31

state 30

    (27) a_term -> a_fact .

    MUL             reduce using rule 27 (a_term -> a_fact .)
    DIV             reduce using rule 27 (a_term -> a_fact .)
    ADD             reduce using rule 27 (a_term -> a_fact .)
    SUB             reduce using rule 27 (a_term -> a_fact .)
    COMMA_DELIM     reduce using rule 27 (a_term -> a_fact .)
    SEMICOLON       reduce using rule 27 (a_term -> a_fact .)
    UNTIL           reduce using rule 27 (a_term -> a_fact .)
    END             reduce using rule 27 (a_term -> a_fact .)
    ELSE            reduce using rule 27 (a_term -> a_fact .)
    LT              reduce using rule 27 (a_term -> a_fact .)
    GT              reduce using rule 27 (a_term -> a_fact .)
    LEQ             reduce using rule 27 (a_term -> a_fact .)
    GEQ             reduce using rule 27 (a_term -> a_fact .)
    EQ              reduce using rule 27 (a_term -> a_fact .)
    NEQ             reduce using rule 27 (a_term -> a_fact .)
    OR              reduce using rule 27 (a_term -> a_fact .)
    AND             reduce using rule 27 (a_term -> a_fact .)
    BEGIN           reduce using rule 27 (a_term -> a_fact .)
    THEN            reduce using rule 27 (a_term -> a_fact .)
    RBRACK          reduce using rule 27 (a_term -> a_fact .)
    RPAREN          reduce using rule 27 (a_term -> a_fact .)


state 31

    (28) a_fact -> varref .
    (34) varref -> varref . LBRACK a_expr RBRACK

    MUL             reduce using rule 28 (a_fact -> varref .)
    DIV             reduce using rule 28 (a_fact -> varref .)
    ADD             reduce using rule 28 (a_fact -> varref .)
    SUB             reduce using rule 28 (a_fact -> varref .)
    COMMA_DELIM     reduce using rule 28 (a_fact -> varref .)
    SEMICOLON       reduce using rule 28 (a_fact -> varref .)
    UNTIL           reduce using rule 28 (a_fact -> varref .)
    END             reduce using rule 28 (a_fact -> varref .)
    ELSE            reduce using rule 28 (a_fact -> varref .)
    LT              reduce using rule 28 (a_fact -> varref .)
    GT              reduce using rule 28 (a_fact -> varref .)
    LEQ             reduce using rule 28 (a_fact -> varref .)
    GEQ             reduce using rule 28 (a_fact -> varref .)
    EQ              reduce using rule 28 (a_fact -> varref .)
    NEQ             reduce using rule 28 (a_fact -> varref .)
    OR              reduce using rule 28 (a_fact -> varref .)
    AND             reduce using rule 28 (a_fact -> varref .)
    BEGIN           reduce using rule 28 (a_fact -> varref .)
    THEN            reduce using rule 28 (a_fact -> varref .)
    RBRACK          reduce using rule 28 (a_fact -> varref .)
    RPAREN          reduce using rule 28 (a_fact -> varref .)
    COLON           reduce using rule 28 (a_fact -> varref .)
    LBRACK          shift and go to state 23


state 32

    (29) a_fact -> NUM .

    MUL             reduce using rule 29 (a_fact -> NUM .)
    DIV             reduce using rule 29 (a_fact -> NUM .)
    ADD             reduce using rule 29 (a_fact -> NUM .)
    SUB             reduce using rule 29 (a_fact -> NUM .)
    COMMA_DELIM     reduce using rule 29 (a_fact -> NUM .)
    SEMICOLON       reduce using rule 29 (a_fact -> NUM .)
    UNTIL           reduce using rule 29 (a_fact -> NUM .)
    END             reduce using rule 29 (a_fact -> NUM .)
    ELSE            reduce using rule 29 (a_fact -> NUM .)
    LT              reduce using rule 29 (a_fact -> NUM .)
    GT              reduce using rule 29 (a_fact -> NUM .)
    LEQ             reduce using rule 29 (a_fact -> NUM .)
    GEQ             reduce using rule 29 (a_fact -> NUM .)
    EQ              reduce using rule 29 (a_fact -> NUM .)
    NEQ             reduce using rule 29 (a_fact -> NUM .)
    OR              reduce using rule 29 (a_fact -> NUM .)
    AND             reduce using rule 29 (a_fact -> NUM .)
    BEGIN           reduce using rule 29 (a_fact -> NUM .)
    THEN            reduce using rule 29 (a_fact -> NUM .)
    RBRACK          reduce using rule 29 (a_fact -> NUM .)
    RPAREN          reduce using rule 29 (a_fact -> NUM .)
    COLON           reduce using rule 29 (a_fact -> NUM .)


state 33

    (30) a_fact -> LITERAL_STR .

    MUL             reduce using rule 30 (a_fact -> LITERAL_STR .)
    DIV             reduce using rule 30 (a_fact -> LITERAL_STR .)
    ADD             reduce using rule 30 (a_fact -> LITERAL_STR .)
    SUB             reduce using rule 30 (a_fact -> LITERAL_STR .)
    COMMA_DELIM     reduce using rule 30 (a_fact -> LITERAL_STR .)
    SEMICOLON       reduce using rule 30 (a_fact -> LITERAL_STR .)
    UNTIL           reduce using rule 30 (a_fact -> LITERAL_STR .)
    END             reduce using rule 30 (a_fact -> LITERAL_STR .)
    ELSE            reduce using rule 30 (a_fact -> LITERAL_STR .)
    LT              reduce using rule 30 (a_fact -> LITERAL_STR .)
    GT              reduce using rule 30 (a_fact -> LITERAL_STR .)
    LEQ             reduce using rule 30 (a_fact -> LITERAL_STR .)
    GEQ             reduce using rule 30 (a_fact -> LITERAL_STR .)
    EQ              reduce using rule 30 (a_fact -> LITERAL_STR .)
    NEQ             reduce using rule 30 (a_fact -> LITERAL_STR .)
    OR              reduce using rule 30 (a_fact -> LITERAL_STR .)
    AND             reduce using rule 30 (a_fact -> LITERAL_STR .)
    BEGIN           reduce using rule 30 (a_fact -> LITERAL_STR .)
    THEN            reduce using rule 30 (a_fact -> LITERAL_STR .)
    RBRACK          reduce using rule 30 (a_fact -> LITERAL_STR .)
    RPAREN          reduce using rule 30 (a_fact -> LITERAL_STR .)
    COLON           reduce using rule 30 (a_fact -> LITERAL_STR .)


state 34

    (32) a_fact -> LPAREN . a_expr RPAREN
    (22) a_expr -> . a_expr ADD a_term
    (23) a_expr -> . a_expr SUB a_term
    (24) a_expr -> . a_term
    (25) a_term -> . a_term MUL a_fact
    (26) a_term -> . a_term DIV a_fact
    (27) a_term -> . a_fact
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_expr                         shift and go to state 54
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 35

    (15) while -> WHILE l_expr . block
    (35) l_expr -> l_expr . AND l_term
    (17) block -> . BEGIN stmt_list END

    AND             shift and go to state 56
    BEGIN           shift and go to state 17

    block                          shift and go to state 55

state 36

    (36) l_expr -> l_term .
    (37) l_term -> l_term . OR l_fact

    AND             reduce using rule 36 (l_expr -> l_term .)
    BEGIN           reduce using rule 36 (l_expr -> l_term .)
    THEN            reduce using rule 36 (l_expr -> l_term .)
    SEMICOLON       reduce using rule 36 (l_expr -> l_term .)
    UNTIL           reduce using rule 36 (l_expr -> l_term .)
    END             reduce using rule 36 (l_expr -> l_term .)
    ELSE            reduce using rule 36 (l_expr -> l_term .)
    RPAREN          reduce using rule 36 (l_expr -> l_term .)
    OR              shift and go to state 57


state 37

    (38) l_term -> l_fact .
    (39) l_fact -> l_fact . oprel a_expr
    (42) oprel -> . LT
    (43) oprel -> . GT
    (44) oprel -> . LEQ
    (45) oprel -> . GEQ
    (46) oprel -> . EQ
    (47) oprel -> . NEQ

    OR              reduce using rule 38 (l_term -> l_fact .)
    AND             reduce using rule 38 (l_term -> l_fact .)
    BEGIN           reduce using rule 38 (l_term -> l_fact .)
    THEN            reduce using rule 38 (l_term -> l_fact .)
    SEMICOLON       reduce using rule 38 (l_term -> l_fact .)
    UNTIL           reduce using rule 38 (l_term -> l_fact .)
    END             reduce using rule 38 (l_term -> l_fact .)
    ELSE            reduce using rule 38 (l_term -> l_fact .)
    RPAREN          reduce using rule 38 (l_term -> l_fact .)
    LT              shift and go to state 59
    GT              shift and go to state 60
    LEQ             shift and go to state 61
    GEQ             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64

    oprel                          shift and go to state 58

state 38

    (40) l_fact -> a_expr .
    (22) a_expr -> a_expr . ADD a_term
    (23) a_expr -> a_expr . SUB a_term

    LT              reduce using rule 40 (l_fact -> a_expr .)
    GT              reduce using rule 40 (l_fact -> a_expr .)
    LEQ             reduce using rule 40 (l_fact -> a_expr .)
    GEQ             reduce using rule 40 (l_fact -> a_expr .)
    EQ              reduce using rule 40 (l_fact -> a_expr .)
    NEQ             reduce using rule 40 (l_fact -> a_expr .)
    OR              reduce using rule 40 (l_fact -> a_expr .)
    AND             reduce using rule 40 (l_fact -> a_expr .)
    BEGIN           reduce using rule 40 (l_fact -> a_expr .)
    THEN            reduce using rule 40 (l_fact -> a_expr .)
    SEMICOLON       reduce using rule 40 (l_fact -> a_expr .)
    UNTIL           reduce using rule 40 (l_fact -> a_expr .)
    END             reduce using rule 40 (l_fact -> a_expr .)
    ELSE            reduce using rule 40 (l_fact -> a_expr .)
    RPAREN          reduce using rule 40 (l_fact -> a_expr .)
    ADD             shift and go to state 49
    SUB             shift and go to state 50


state 39

    (41) l_fact -> LPAREN . l_expr RPAREN
    (32) a_fact -> LPAREN . a_expr RPAREN
    (35) l_expr -> . l_expr AND l_term
    (36) l_expr -> . l_term
    (22) a_expr -> . a_expr ADD a_term
    (23) a_expr -> . a_expr SUB a_term
    (24) a_expr -> . a_term
    (37) l_term -> . l_term OR l_fact
    (38) l_term -> . l_fact
    (25) a_term -> . a_term MUL a_fact
    (26) a_term -> . a_term DIV a_fact
    (27) a_term -> . a_fact
    (39) l_fact -> . l_fact oprel a_expr
    (40) l_fact -> . a_expr
    (41) l_fact -> . LPAREN l_expr RPAREN
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 39
    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    ID              shift and go to state 19

    l_expr                         shift and go to state 65
    a_expr                         shift and go to state 66
    l_term                         shift and go to state 36
    a_term                         shift and go to state 28
    l_fact                         shift and go to state 37
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 40

    (16) repeat -> REPEAT stmt_list . UNTIL l_expr
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    UNTIL           shift and go to state 67
    SEMICOLON       shift and go to state 68


state 41

    (17) block -> BEGIN stmt_list . END
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    END             shift and go to state 69
    SEMICOLON       shift and go to state 68


state 42

    (18) foreach -> FOREACH ID . IN LPAREN a_fact COLON a_fact RPAREN stmt

    IN              shift and go to state 70


state 43

    (19) if_stmt -> IF l_expr . THEN stmt_list ELSE else_stmt
    (35) l_expr -> l_expr . AND l_term

    THEN            shift and go to state 71
    AND             shift and go to state 56


state 44

    (2) stmt_list -> stmt_list SEMICOLON stmt .

    SEMICOLON       reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)
    UNTIL           reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)
    END             reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)
    ELSE            reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)


state 45

    (12) assignment -> varref ASSIGN l_expr .
    (35) l_expr -> l_expr . AND l_term

    SEMICOLON       reduce using rule 12 (assignment -> varref ASSIGN l_expr .)
    UNTIL           reduce using rule 12 (assignment -> varref ASSIGN l_expr .)
    END             reduce using rule 12 (assignment -> varref ASSIGN l_expr .)
    ELSE            reduce using rule 12 (assignment -> varref ASSIGN l_expr .)
    AND             shift and go to state 56


state 46

    (34) varref -> varref LBRACK a_expr . RBRACK
    (22) a_expr -> a_expr . ADD a_term
    (23) a_expr -> a_expr . SUB a_term

    RBRACK          shift and go to state 72
    ADD             shift and go to state 49
    SUB             shift and go to state 50


state 47

    (49) varlist -> varref COMMA_DELIM . varlist
    (48) varlist -> . varref
    (49) varlist -> . varref COMMA_DELIM varlist
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    ID              shift and go to state 19

    varref                         shift and go to state 25
    varlist                        shift and go to state 73

state 48

    (51) expr_list -> expr_list COMMA_DELIM . a_expr
    (22) a_expr -> . a_expr ADD a_term
    (23) a_expr -> . a_expr SUB a_term
    (24) a_expr -> . a_term
    (25) a_term -> . a_term MUL a_fact
    (26) a_term -> . a_term DIV a_fact
    (27) a_term -> . a_fact
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_expr                         shift and go to state 74
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 49

    (22) a_expr -> a_expr ADD . a_term
    (25) a_term -> . a_term MUL a_fact
    (26) a_term -> . a_term DIV a_fact
    (27) a_term -> . a_fact
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_term                         shift and go to state 75
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 50

    (23) a_expr -> a_expr SUB . a_term
    (25) a_term -> . a_term MUL a_fact
    (26) a_term -> . a_term DIV a_fact
    (27) a_term -> . a_fact
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_term                         shift and go to state 76
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 51

    (25) a_term -> a_term MUL . a_fact
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_fact                         shift and go to state 77
    varref                         shift and go to state 31

state 52

    (26) a_term -> a_term DIV . a_fact
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_fact                         shift and go to state 78
    varref                         shift and go to state 31

state 53

    (31) a_fact -> SUB a_fact .

    MUL             reduce using rule 31 (a_fact -> SUB a_fact .)
    DIV             reduce using rule 31 (a_fact -> SUB a_fact .)
    ADD             reduce using rule 31 (a_fact -> SUB a_fact .)
    SUB             reduce using rule 31 (a_fact -> SUB a_fact .)
    COMMA_DELIM     reduce using rule 31 (a_fact -> SUB a_fact .)
    SEMICOLON       reduce using rule 31 (a_fact -> SUB a_fact .)
    UNTIL           reduce using rule 31 (a_fact -> SUB a_fact .)
    END             reduce using rule 31 (a_fact -> SUB a_fact .)
    ELSE            reduce using rule 31 (a_fact -> SUB a_fact .)
    LT              reduce using rule 31 (a_fact -> SUB a_fact .)
    GT              reduce using rule 31 (a_fact -> SUB a_fact .)
    LEQ             reduce using rule 31 (a_fact -> SUB a_fact .)
    GEQ             reduce using rule 31 (a_fact -> SUB a_fact .)
    EQ              reduce using rule 31 (a_fact -> SUB a_fact .)
    NEQ             reduce using rule 31 (a_fact -> SUB a_fact .)
    OR              reduce using rule 31 (a_fact -> SUB a_fact .)
    AND             reduce using rule 31 (a_fact -> SUB a_fact .)
    BEGIN           reduce using rule 31 (a_fact -> SUB a_fact .)
    THEN            reduce using rule 31 (a_fact -> SUB a_fact .)
    RBRACK          reduce using rule 31 (a_fact -> SUB a_fact .)
    RPAREN          reduce using rule 31 (a_fact -> SUB a_fact .)
    COLON           reduce using rule 31 (a_fact -> SUB a_fact .)


state 54

    (32) a_fact -> LPAREN a_expr . RPAREN
    (22) a_expr -> a_expr . ADD a_term
    (23) a_expr -> a_expr . SUB a_term

    RPAREN          shift and go to state 79
    ADD             shift and go to state 49
    SUB             shift and go to state 50


state 55

    (15) while -> WHILE l_expr block .

    SEMICOLON       reduce using rule 15 (while -> WHILE l_expr block .)
    UNTIL           reduce using rule 15 (while -> WHILE l_expr block .)
    END             reduce using rule 15 (while -> WHILE l_expr block .)
    ELSE            reduce using rule 15 (while -> WHILE l_expr block .)


state 56

    (35) l_expr -> l_expr AND . l_term
    (37) l_term -> . l_term OR l_fact
    (38) l_term -> . l_fact
    (39) l_fact -> . l_fact oprel a_expr
    (40) l_fact -> . a_expr
    (41) l_fact -> . LPAREN l_expr RPAREN
    (22) a_expr -> . a_expr ADD a_term
    (23) a_expr -> . a_expr SUB a_term
    (24) a_expr -> . a_term
    (25) a_term -> . a_term MUL a_fact
    (26) a_term -> . a_term DIV a_fact
    (27) a_term -> . a_fact
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 39
    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    ID              shift and go to state 19

    l_term                         shift and go to state 80
    l_fact                         shift and go to state 37
    a_expr                         shift and go to state 38
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 57

    (37) l_term -> l_term OR . l_fact
    (39) l_fact -> . l_fact oprel a_expr
    (40) l_fact -> . a_expr
    (41) l_fact -> . LPAREN l_expr RPAREN
    (22) a_expr -> . a_expr ADD a_term
    (23) a_expr -> . a_expr SUB a_term
    (24) a_expr -> . a_term
    (25) a_term -> . a_term MUL a_fact
    (26) a_term -> . a_term DIV a_fact
    (27) a_term -> . a_fact
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 39
    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    ID              shift and go to state 19

    l_fact                         shift and go to state 81
    a_expr                         shift and go to state 38
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 58

    (39) l_fact -> l_fact oprel . a_expr
    (22) a_expr -> . a_expr ADD a_term
    (23) a_expr -> . a_expr SUB a_term
    (24) a_expr -> . a_term
    (25) a_term -> . a_term MUL a_fact
    (26) a_term -> . a_term DIV a_fact
    (27) a_term -> . a_fact
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_expr                         shift and go to state 82
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 59

    (42) oprel -> LT .

    NUM             reduce using rule 42 (oprel -> LT .)
    LITERAL_STR     reduce using rule 42 (oprel -> LT .)
    SUB             reduce using rule 42 (oprel -> LT .)
    LPAREN          reduce using rule 42 (oprel -> LT .)
    ID              reduce using rule 42 (oprel -> LT .)


state 60

    (43) oprel -> GT .

    NUM             reduce using rule 43 (oprel -> GT .)
    LITERAL_STR     reduce using rule 43 (oprel -> GT .)
    SUB             reduce using rule 43 (oprel -> GT .)
    LPAREN          reduce using rule 43 (oprel -> GT .)
    ID              reduce using rule 43 (oprel -> GT .)


state 61

    (44) oprel -> LEQ .

    NUM             reduce using rule 44 (oprel -> LEQ .)
    LITERAL_STR     reduce using rule 44 (oprel -> LEQ .)
    SUB             reduce using rule 44 (oprel -> LEQ .)
    LPAREN          reduce using rule 44 (oprel -> LEQ .)
    ID              reduce using rule 44 (oprel -> LEQ .)


state 62

    (45) oprel -> GEQ .

    NUM             reduce using rule 45 (oprel -> GEQ .)
    LITERAL_STR     reduce using rule 45 (oprel -> GEQ .)
    SUB             reduce using rule 45 (oprel -> GEQ .)
    LPAREN          reduce using rule 45 (oprel -> GEQ .)
    ID              reduce using rule 45 (oprel -> GEQ .)


state 63

    (46) oprel -> EQ .

    NUM             reduce using rule 46 (oprel -> EQ .)
    LITERAL_STR     reduce using rule 46 (oprel -> EQ .)
    SUB             reduce using rule 46 (oprel -> EQ .)
    LPAREN          reduce using rule 46 (oprel -> EQ .)
    ID              reduce using rule 46 (oprel -> EQ .)


state 64

    (47) oprel -> NEQ .

    NUM             reduce using rule 47 (oprel -> NEQ .)
    LITERAL_STR     reduce using rule 47 (oprel -> NEQ .)
    SUB             reduce using rule 47 (oprel -> NEQ .)
    LPAREN          reduce using rule 47 (oprel -> NEQ .)
    ID              reduce using rule 47 (oprel -> NEQ .)


state 65

    (41) l_fact -> LPAREN l_expr . RPAREN
    (35) l_expr -> l_expr . AND l_term

    RPAREN          shift and go to state 83
    AND             shift and go to state 56


state 66

    (32) a_fact -> LPAREN a_expr . RPAREN
    (22) a_expr -> a_expr . ADD a_term
    (23) a_expr -> a_expr . SUB a_term
    (40) l_fact -> a_expr .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 79
    ADD             shift and go to state 49
    SUB             shift and go to state 50
    LT              reduce using rule 40 (l_fact -> a_expr .)
    GT              reduce using rule 40 (l_fact -> a_expr .)
    LEQ             reduce using rule 40 (l_fact -> a_expr .)
    GEQ             reduce using rule 40 (l_fact -> a_expr .)
    EQ              reduce using rule 40 (l_fact -> a_expr .)
    NEQ             reduce using rule 40 (l_fact -> a_expr .)
    OR              reduce using rule 40 (l_fact -> a_expr .)
    AND             reduce using rule 40 (l_fact -> a_expr .)

  ! RPAREN          [ reduce using rule 40 (l_fact -> a_expr .) ]


state 67

    (16) repeat -> REPEAT stmt_list UNTIL . l_expr
    (35) l_expr -> . l_expr AND l_term
    (36) l_expr -> . l_term
    (37) l_term -> . l_term OR l_fact
    (38) l_term -> . l_fact
    (39) l_fact -> . l_fact oprel a_expr
    (40) l_fact -> . a_expr
    (41) l_fact -> . LPAREN l_expr RPAREN
    (22) a_expr -> . a_expr ADD a_term
    (23) a_expr -> . a_expr SUB a_term
    (24) a_expr -> . a_term
    (25) a_term -> . a_term MUL a_fact
    (26) a_term -> . a_term DIV a_fact
    (27) a_term -> . a_fact
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 39
    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    ID              shift and go to state 19

    l_expr                         shift and go to state 84
    l_term                         shift and go to state 36
    l_fact                         shift and go to state 37
    a_expr                         shift and go to state 38
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 68

    (2) stmt_list -> stmt_list SEMICOLON . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt                           shift and go to state 44
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 69

    (17) block -> BEGIN stmt_list END .

    SEMICOLON       reduce using rule 17 (block -> BEGIN stmt_list END .)
    UNTIL           reduce using rule 17 (block -> BEGIN stmt_list END .)
    END             reduce using rule 17 (block -> BEGIN stmt_list END .)
    ELSE            reduce using rule 17 (block -> BEGIN stmt_list END .)


state 70

    (18) foreach -> FOREACH ID IN . LPAREN a_fact COLON a_fact RPAREN stmt

    LPAREN          shift and go to state 85


state 71

    (19) if_stmt -> IF l_expr THEN . stmt_list ELSE else_stmt
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt_list                      shift and go to state 86
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 72

    (34) varref -> varref LBRACK a_expr RBRACK .

    ASSIGN          reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    LBRACK          reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    COMMA_DELIM     reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    SEMICOLON       reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    UNTIL           reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    END             reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    ELSE            reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    MUL             reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    DIV             reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    ADD             reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    SUB             reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    LT              reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    GT              reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    LEQ             reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    GEQ             reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    EQ              reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    NEQ             reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    OR              reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    AND             reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    BEGIN           reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    THEN            reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    RBRACK          reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    RPAREN          reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)
    COLON           reduce using rule 34 (varref -> varref LBRACK a_expr RBRACK .)


state 73

    (49) varlist -> varref COMMA_DELIM varlist .

    SEMICOLON       reduce using rule 49 (varlist -> varref COMMA_DELIM varlist .)
    UNTIL           reduce using rule 49 (varlist -> varref COMMA_DELIM varlist .)
    END             reduce using rule 49 (varlist -> varref COMMA_DELIM varlist .)
    ELSE            reduce using rule 49 (varlist -> varref COMMA_DELIM varlist .)


state 74

    (51) expr_list -> expr_list COMMA_DELIM a_expr .
    (22) a_expr -> a_expr . ADD a_term
    (23) a_expr -> a_expr . SUB a_term

    COMMA_DELIM     reduce using rule 51 (expr_list -> expr_list COMMA_DELIM a_expr .)
    SEMICOLON       reduce using rule 51 (expr_list -> expr_list COMMA_DELIM a_expr .)
    UNTIL           reduce using rule 51 (expr_list -> expr_list COMMA_DELIM a_expr .)
    END             reduce using rule 51 (expr_list -> expr_list COMMA_DELIM a_expr .)
    ELSE            reduce using rule 51 (expr_list -> expr_list COMMA_DELIM a_expr .)
    ADD             shift and go to state 49
    SUB             shift and go to state 50


state 75

    (22) a_expr -> a_expr ADD a_term .
    (25) a_term -> a_term . MUL a_fact
    (26) a_term -> a_term . DIV a_fact

    ADD             reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    SUB             reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    COMMA_DELIM     reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    SEMICOLON       reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    UNTIL           reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    END             reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    ELSE            reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    LT              reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    GT              reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    LEQ             reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    GEQ             reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    EQ              reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    NEQ             reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    OR              reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    AND             reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    BEGIN           reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    THEN            reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    RBRACK          reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    RPAREN          reduce using rule 22 (a_expr -> a_expr ADD a_term .)
    MUL             shift and go to state 51
    DIV             shift and go to state 52


state 76

    (23) a_expr -> a_expr SUB a_term .
    (25) a_term -> a_term . MUL a_fact
    (26) a_term -> a_term . DIV a_fact

    ADD             reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    SUB             reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    COMMA_DELIM     reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    SEMICOLON       reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    UNTIL           reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    END             reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    ELSE            reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    LT              reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    GT              reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    LEQ             reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    GEQ             reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    EQ              reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    NEQ             reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    OR              reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    AND             reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    BEGIN           reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    THEN            reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    RBRACK          reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    RPAREN          reduce using rule 23 (a_expr -> a_expr SUB a_term .)
    MUL             shift and go to state 51
    DIV             shift and go to state 52


state 77

    (25) a_term -> a_term MUL a_fact .

    MUL             reduce using rule 25 (a_term -> a_term MUL a_fact .)
    DIV             reduce using rule 25 (a_term -> a_term MUL a_fact .)
    ADD             reduce using rule 25 (a_term -> a_term MUL a_fact .)
    SUB             reduce using rule 25 (a_term -> a_term MUL a_fact .)
    COMMA_DELIM     reduce using rule 25 (a_term -> a_term MUL a_fact .)
    SEMICOLON       reduce using rule 25 (a_term -> a_term MUL a_fact .)
    UNTIL           reduce using rule 25 (a_term -> a_term MUL a_fact .)
    END             reduce using rule 25 (a_term -> a_term MUL a_fact .)
    ELSE            reduce using rule 25 (a_term -> a_term MUL a_fact .)
    LT              reduce using rule 25 (a_term -> a_term MUL a_fact .)
    GT              reduce using rule 25 (a_term -> a_term MUL a_fact .)
    LEQ             reduce using rule 25 (a_term -> a_term MUL a_fact .)
    GEQ             reduce using rule 25 (a_term -> a_term MUL a_fact .)
    EQ              reduce using rule 25 (a_term -> a_term MUL a_fact .)
    NEQ             reduce using rule 25 (a_term -> a_term MUL a_fact .)
    OR              reduce using rule 25 (a_term -> a_term MUL a_fact .)
    AND             reduce using rule 25 (a_term -> a_term MUL a_fact .)
    BEGIN           reduce using rule 25 (a_term -> a_term MUL a_fact .)
    THEN            reduce using rule 25 (a_term -> a_term MUL a_fact .)
    RBRACK          reduce using rule 25 (a_term -> a_term MUL a_fact .)
    RPAREN          reduce using rule 25 (a_term -> a_term MUL a_fact .)


state 78

    (26) a_term -> a_term DIV a_fact .

    MUL             reduce using rule 26 (a_term -> a_term DIV a_fact .)
    DIV             reduce using rule 26 (a_term -> a_term DIV a_fact .)
    ADD             reduce using rule 26 (a_term -> a_term DIV a_fact .)
    SUB             reduce using rule 26 (a_term -> a_term DIV a_fact .)
    COMMA_DELIM     reduce using rule 26 (a_term -> a_term DIV a_fact .)
    SEMICOLON       reduce using rule 26 (a_term -> a_term DIV a_fact .)
    UNTIL           reduce using rule 26 (a_term -> a_term DIV a_fact .)
    END             reduce using rule 26 (a_term -> a_term DIV a_fact .)
    ELSE            reduce using rule 26 (a_term -> a_term DIV a_fact .)
    LT              reduce using rule 26 (a_term -> a_term DIV a_fact .)
    GT              reduce using rule 26 (a_term -> a_term DIV a_fact .)
    LEQ             reduce using rule 26 (a_term -> a_term DIV a_fact .)
    GEQ             reduce using rule 26 (a_term -> a_term DIV a_fact .)
    EQ              reduce using rule 26 (a_term -> a_term DIV a_fact .)
    NEQ             reduce using rule 26 (a_term -> a_term DIV a_fact .)
    OR              reduce using rule 26 (a_term -> a_term DIV a_fact .)
    AND             reduce using rule 26 (a_term -> a_term DIV a_fact .)
    BEGIN           reduce using rule 26 (a_term -> a_term DIV a_fact .)
    THEN            reduce using rule 26 (a_term -> a_term DIV a_fact .)
    RBRACK          reduce using rule 26 (a_term -> a_term DIV a_fact .)
    RPAREN          reduce using rule 26 (a_term -> a_term DIV a_fact .)


state 79

    (32) a_fact -> LPAREN a_expr RPAREN .

    MUL             reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    DIV             reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    ADD             reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    SUB             reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    COMMA_DELIM     reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    SEMICOLON       reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    UNTIL           reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    END             reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    ELSE            reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    LT              reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    GT              reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    LEQ             reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    GEQ             reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    EQ              reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    NEQ             reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    OR              reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    AND             reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    BEGIN           reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    THEN            reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    RBRACK          reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    RPAREN          reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)
    COLON           reduce using rule 32 (a_fact -> LPAREN a_expr RPAREN .)


state 80

    (35) l_expr -> l_expr AND l_term .
    (37) l_term -> l_term . OR l_fact

    AND             reduce using rule 35 (l_expr -> l_expr AND l_term .)
    BEGIN           reduce using rule 35 (l_expr -> l_expr AND l_term .)
    THEN            reduce using rule 35 (l_expr -> l_expr AND l_term .)
    SEMICOLON       reduce using rule 35 (l_expr -> l_expr AND l_term .)
    UNTIL           reduce using rule 35 (l_expr -> l_expr AND l_term .)
    END             reduce using rule 35 (l_expr -> l_expr AND l_term .)
    ELSE            reduce using rule 35 (l_expr -> l_expr AND l_term .)
    RPAREN          reduce using rule 35 (l_expr -> l_expr AND l_term .)
    OR              shift and go to state 57


state 81

    (37) l_term -> l_term OR l_fact .
    (39) l_fact -> l_fact . oprel a_expr
    (42) oprel -> . LT
    (43) oprel -> . GT
    (44) oprel -> . LEQ
    (45) oprel -> . GEQ
    (46) oprel -> . EQ
    (47) oprel -> . NEQ

    OR              reduce using rule 37 (l_term -> l_term OR l_fact .)
    AND             reduce using rule 37 (l_term -> l_term OR l_fact .)
    BEGIN           reduce using rule 37 (l_term -> l_term OR l_fact .)
    THEN            reduce using rule 37 (l_term -> l_term OR l_fact .)
    SEMICOLON       reduce using rule 37 (l_term -> l_term OR l_fact .)
    UNTIL           reduce using rule 37 (l_term -> l_term OR l_fact .)
    END             reduce using rule 37 (l_term -> l_term OR l_fact .)
    ELSE            reduce using rule 37 (l_term -> l_term OR l_fact .)
    RPAREN          reduce using rule 37 (l_term -> l_term OR l_fact .)
    LT              shift and go to state 59
    GT              shift and go to state 60
    LEQ             shift and go to state 61
    GEQ             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64

    oprel                          shift and go to state 58

state 82

    (39) l_fact -> l_fact oprel a_expr .
    (22) a_expr -> a_expr . ADD a_term
    (23) a_expr -> a_expr . SUB a_term

    LT              reduce using rule 39 (l_fact -> l_fact oprel a_expr .)
    GT              reduce using rule 39 (l_fact -> l_fact oprel a_expr .)
    LEQ             reduce using rule 39 (l_fact -> l_fact oprel a_expr .)
    GEQ             reduce using rule 39 (l_fact -> l_fact oprel a_expr .)
    EQ              reduce using rule 39 (l_fact -> l_fact oprel a_expr .)
    NEQ             reduce using rule 39 (l_fact -> l_fact oprel a_expr .)
    OR              reduce using rule 39 (l_fact -> l_fact oprel a_expr .)
    AND             reduce using rule 39 (l_fact -> l_fact oprel a_expr .)
    BEGIN           reduce using rule 39 (l_fact -> l_fact oprel a_expr .)
    THEN            reduce using rule 39 (l_fact -> l_fact oprel a_expr .)
    SEMICOLON       reduce using rule 39 (l_fact -> l_fact oprel a_expr .)
    UNTIL           reduce using rule 39 (l_fact -> l_fact oprel a_expr .)
    END             reduce using rule 39 (l_fact -> l_fact oprel a_expr .)
    ELSE            reduce using rule 39 (l_fact -> l_fact oprel a_expr .)
    RPAREN          reduce using rule 39 (l_fact -> l_fact oprel a_expr .)
    ADD             shift and go to state 49
    SUB             shift and go to state 50


state 83

    (41) l_fact -> LPAREN l_expr RPAREN .

    LT              reduce using rule 41 (l_fact -> LPAREN l_expr RPAREN .)
    GT              reduce using rule 41 (l_fact -> LPAREN l_expr RPAREN .)
    LEQ             reduce using rule 41 (l_fact -> LPAREN l_expr RPAREN .)
    GEQ             reduce using rule 41 (l_fact -> LPAREN l_expr RPAREN .)
    EQ              reduce using rule 41 (l_fact -> LPAREN l_expr RPAREN .)
    NEQ             reduce using rule 41 (l_fact -> LPAREN l_expr RPAREN .)
    OR              reduce using rule 41 (l_fact -> LPAREN l_expr RPAREN .)
    AND             reduce using rule 41 (l_fact -> LPAREN l_expr RPAREN .)
    BEGIN           reduce using rule 41 (l_fact -> LPAREN l_expr RPAREN .)
    THEN            reduce using rule 41 (l_fact -> LPAREN l_expr RPAREN .)
    SEMICOLON       reduce using rule 41 (l_fact -> LPAREN l_expr RPAREN .)
    UNTIL           reduce using rule 41 (l_fact -> LPAREN l_expr RPAREN .)
    END             reduce using rule 41 (l_fact -> LPAREN l_expr RPAREN .)
    ELSE            reduce using rule 41 (l_fact -> LPAREN l_expr RPAREN .)
    RPAREN          reduce using rule 41 (l_fact -> LPAREN l_expr RPAREN .)


state 84

    (16) repeat -> REPEAT stmt_list UNTIL l_expr .
    (35) l_expr -> l_expr . AND l_term

    SEMICOLON       reduce using rule 16 (repeat -> REPEAT stmt_list UNTIL l_expr .)
    UNTIL           reduce using rule 16 (repeat -> REPEAT stmt_list UNTIL l_expr .)
    END             reduce using rule 16 (repeat -> REPEAT stmt_list UNTIL l_expr .)
    ELSE            reduce using rule 16 (repeat -> REPEAT stmt_list UNTIL l_expr .)
    AND             shift and go to state 56


state 85

    (18) foreach -> FOREACH ID IN LPAREN . a_fact COLON a_fact RPAREN stmt
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_fact                         shift and go to state 87
    varref                         shift and go to state 31

state 86

    (19) if_stmt -> IF l_expr THEN stmt_list . ELSE else_stmt
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    ELSE            shift and go to state 88
    SEMICOLON       shift and go to state 68


state 87

    (18) foreach -> FOREACH ID IN LPAREN a_fact . COLON a_fact RPAREN stmt

    COLON           shift and go to state 89


state 88

    (19) if_stmt -> IF l_expr THEN stmt_list ELSE . else_stmt
    (20) else_stmt -> .
    (21) else_stmt -> . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 20 (else_stmt -> .)
    UNTIL           reduce using rule 20 (else_stmt -> .)
    END             reduce using rule 20 (else_stmt -> .)
    ELSE            shift and go to state 90

  ! ELSE            [ reduce using rule 20 (else_stmt -> .) ]

    else_stmt                      shift and go to state 91

state 89

    (18) foreach -> FOREACH ID IN LPAREN a_fact COLON . a_fact RPAREN stmt
    (28) a_fact -> . varref
    (29) a_fact -> . NUM
    (30) a_fact -> . LITERAL_STR
    (31) a_fact -> . SUB a_fact
    (32) a_fact -> . LPAREN a_expr RPAREN
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_fact                         shift and go to state 92
    varref                         shift and go to state 31

state 90

    (21) else_stmt -> ELSE . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt                           shift and go to state 93
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 91

    (19) if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt .

    SEMICOLON       reduce using rule 19 (if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt .)
    UNTIL           reduce using rule 19 (if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt .)
    END             reduce using rule 19 (if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt .)
    ELSE            reduce using rule 19 (if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt .)


state 92

    (18) foreach -> FOREACH ID IN LPAREN a_fact COLON a_fact . RPAREN stmt

    RPAREN          shift and go to state 94


state 93

    (21) else_stmt -> ELSE stmt .

    SEMICOLON       reduce using rule 21 (else_stmt -> ELSE stmt .)
    UNTIL           reduce using rule 21 (else_stmt -> ELSE stmt .)
    END             reduce using rule 21 (else_stmt -> ELSE stmt .)
    ELSE            reduce using rule 21 (else_stmt -> ELSE stmt .)


state 94

    (18) foreach -> FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (33) varref -> . ID
    (34) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt                           shift and go to state 95
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 95

    (18) foreach -> FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt .

    SEMICOLON       reduce using rule 18 (foreach -> FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt .)
    UNTIL           reduce using rule 18 (foreach -> FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt .)
    END             reduce using rule 18 (foreach -> FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt .)
    ELSE            reduce using rule 18 (foreach -> FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAREN in state 66 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 88 resolved as shift
