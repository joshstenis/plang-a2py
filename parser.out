Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt_list SEMICOLON
Rule 2     stmt_list -> stmt_list SEMICOLON stmt
Rule 3     stmt_list -> stmt
Rule 4     stmt -> assignment
Rule 5     stmt -> read
Rule 6     stmt -> write
Rule 7     stmt -> while
Rule 8     stmt -> repeat
Rule 9     stmt -> block
Rule 10    stmt -> foreach
Rule 11    stmt -> if_stmt
Rule 12    assignment -> varref ASSIGN l_expr
Rule 13    read -> READ varlist
Rule 14    write -> WRITE expr_list
Rule 15    while -> WHILE l_expr block
Rule 16    repeat -> REPEAT stmt_list UNTIL l_expr
Rule 17    block -> BEGIN stmt_list END
Rule 18    foreach -> FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
Rule 19    if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt
Rule 20    else_stmt -> <empty>
Rule 21    else_stmt -> ELSE stmt
Rule 22    a_expr -> a_expr a_op a_expr
Rule 23    a_expr -> SUB a_expr
Rule 24    a_expr -> varref
Rule 25    a_expr -> NUM
Rule 26    a_expr -> LITERAL_STR
Rule 27    a_expr -> LPAREN a_expr RPAREN
Rule 28    a_op -> ADD
Rule 29    a_op -> SUB
Rule 30    a_op -> MUL
Rule 31    a_op -> DIV
Rule 32    varref -> ID
Rule 33    varref -> varref LBRACK a_expr RBRACK
Rule 34    l_expr -> l_expr AND l_term
Rule 35    l_expr -> l_term
Rule 36    l_term -> l_term OR l_fact
Rule 37    l_term -> l_fact
Rule 38    l_fact -> l_fact oprel a_expr
Rule 39    l_fact -> a_expr
Rule 40    l_fact -> LPAREN l_expr RPAREN
Rule 41    oprel -> LT
Rule 42    oprel -> GT
Rule 43    oprel -> LEQ
Rule 44    oprel -> GEQ
Rule 45    oprel -> EQ
Rule 46    oprel -> NEQ
Rule 47    varlist -> varref
Rule 48    varlist -> varref COMMA varlist
Rule 49    expr_list -> a_expr
Rule 50    expr_list -> expr_list COMMA a_expr

Terminals, with rules where they appear

ADD                  : 28
AND                  : 34
ASSIGN               : 12
BEGIN                : 17
COLON                : 18
COMMA                : 48 50
COMMENT              : 
DIV                  : 31
ELSE                 : 19 21
END                  : 17
EQ                   : 45
FOREACH              : 18
GEQ                  : 44
GT                   : 42
ID                   : 18 32
IF                   : 19
IN                   : 18
LBRACK               : 33
LEQ                  : 43
LITERAL_STR          : 26
LPAREN               : 18 27 40
LT                   : 41
MUL                  : 30
NEQ                  : 46
NUM                  : 25
OR                   : 36
RBRACK               : 33
READ                 : 13
REPEAT               : 16
RPAREN               : 18 27 40
SEMICOLON            : 1 2
SUB                  : 23 29
THEN                 : 19
UNTIL                : 16
WHILE                : 15
WRITE                : 14
error                : 

Nonterminals, with rules where they appear

a_expr               : 18 18 22 22 23 27 33 38 39 49 50
a_op                 : 22
assignment           : 4
block                : 9 15
else_stmt            : 19
expr_list            : 14 50
foreach              : 10
if_stmt              : 11
l_expr               : 12 15 16 19 34 40
l_fact               : 36 37 38
l_term               : 34 35 36
oprel                : 38
program              : 0
read                 : 5
repeat               : 8
stmt                 : 2 3 18 21
stmt_list            : 1 2 16 17 19
varlist              : 13 48
varref               : 12 24 33 47 48
while                : 7
write                : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt_list SEMICOLON
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt_list . SEMICOLON
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    SEMICOLON       shift and go to state 21


state 3

    (3) stmt_list -> stmt .

    SEMICOLON       reduce using rule 3 (stmt_list -> stmt .)
    UNTIL           reduce using rule 3 (stmt_list -> stmt .)
    END             reduce using rule 3 (stmt_list -> stmt .)
    ELSE            reduce using rule 3 (stmt_list -> stmt .)


state 4

    (4) stmt -> assignment .

    SEMICOLON       reduce using rule 4 (stmt -> assignment .)
    UNTIL           reduce using rule 4 (stmt -> assignment .)
    END             reduce using rule 4 (stmt -> assignment .)
    ELSE            reduce using rule 4 (stmt -> assignment .)


state 5

    (5) stmt -> read .

    SEMICOLON       reduce using rule 5 (stmt -> read .)
    UNTIL           reduce using rule 5 (stmt -> read .)
    END             reduce using rule 5 (stmt -> read .)
    ELSE            reduce using rule 5 (stmt -> read .)


state 6

    (6) stmt -> write .

    SEMICOLON       reduce using rule 6 (stmt -> write .)
    UNTIL           reduce using rule 6 (stmt -> write .)
    END             reduce using rule 6 (stmt -> write .)
    ELSE            reduce using rule 6 (stmt -> write .)


state 7

    (7) stmt -> while .

    SEMICOLON       reduce using rule 7 (stmt -> while .)
    UNTIL           reduce using rule 7 (stmt -> while .)
    END             reduce using rule 7 (stmt -> while .)
    ELSE            reduce using rule 7 (stmt -> while .)


state 8

    (8) stmt -> repeat .

    SEMICOLON       reduce using rule 8 (stmt -> repeat .)
    UNTIL           reduce using rule 8 (stmt -> repeat .)
    END             reduce using rule 8 (stmt -> repeat .)
    ELSE            reduce using rule 8 (stmt -> repeat .)


state 9

    (9) stmt -> block .

    SEMICOLON       reduce using rule 9 (stmt -> block .)
    UNTIL           reduce using rule 9 (stmt -> block .)
    END             reduce using rule 9 (stmt -> block .)
    ELSE            reduce using rule 9 (stmt -> block .)


state 10

    (10) stmt -> foreach .

    SEMICOLON       reduce using rule 10 (stmt -> foreach .)
    UNTIL           reduce using rule 10 (stmt -> foreach .)
    END             reduce using rule 10 (stmt -> foreach .)
    ELSE            reduce using rule 10 (stmt -> foreach .)


state 11

    (11) stmt -> if_stmt .

    SEMICOLON       reduce using rule 11 (stmt -> if_stmt .)
    UNTIL           reduce using rule 11 (stmt -> if_stmt .)
    END             reduce using rule 11 (stmt -> if_stmt .)
    ELSE            reduce using rule 11 (stmt -> if_stmt .)


state 12

    (12) assignment -> varref . ASSIGN l_expr
    (33) varref -> varref . LBRACK a_expr RBRACK

    ASSIGN          shift and go to state 22
    LBRACK          shift and go to state 23


state 13

    (13) read -> READ . varlist
    (47) varlist -> . varref
    (48) varlist -> . varref COMMA varlist
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    ID              shift and go to state 19

    varlist                        shift and go to state 24
    varref                         shift and go to state 25

state 14

    (14) write -> WRITE . expr_list
    (49) expr_list -> . a_expr
    (50) expr_list -> . expr_list COMMA a_expr
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . varref
    (25) a_expr -> . NUM
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    SUB             shift and go to state 28
    NUM             shift and go to state 30
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    expr_list                      shift and go to state 26
    a_expr                         shift and go to state 27
    varref                         shift and go to state 29

state 15

    (15) while -> WHILE . l_expr block
    (34) l_expr -> . l_expr AND l_term
    (35) l_expr -> . l_term
    (36) l_term -> . l_term OR l_fact
    (37) l_term -> . l_fact
    (38) l_fact -> . l_fact oprel a_expr
    (39) l_fact -> . a_expr
    (40) l_fact -> . LPAREN l_expr RPAREN
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . varref
    (25) a_expr -> . NUM
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 37
    SUB             shift and go to state 28
    NUM             shift and go to state 30
    LITERAL_STR     shift and go to state 31
    ID              shift and go to state 19

    l_expr                         shift and go to state 33
    l_term                         shift and go to state 34
    l_fact                         shift and go to state 35
    a_expr                         shift and go to state 36
    varref                         shift and go to state 29

state 16

    (16) repeat -> REPEAT . stmt_list UNTIL l_expr
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt_list                      shift and go to state 38
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 17

    (17) block -> BEGIN . stmt_list END
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt_list                      shift and go to state 39
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 18

    (18) foreach -> FOREACH . ID IN LPAREN a_expr COLON a_expr RPAREN stmt

    ID              shift and go to state 40


state 19

    (32) varref -> ID .

    ASSIGN          reduce using rule 32 (varref -> ID .)
    LBRACK          reduce using rule 32 (varref -> ID .)
    COMMA           reduce using rule 32 (varref -> ID .)
    SEMICOLON       reduce using rule 32 (varref -> ID .)
    UNTIL           reduce using rule 32 (varref -> ID .)
    END             reduce using rule 32 (varref -> ID .)
    ELSE            reduce using rule 32 (varref -> ID .)
    ADD             reduce using rule 32 (varref -> ID .)
    SUB             reduce using rule 32 (varref -> ID .)
    MUL             reduce using rule 32 (varref -> ID .)
    DIV             reduce using rule 32 (varref -> ID .)
    LT              reduce using rule 32 (varref -> ID .)
    GT              reduce using rule 32 (varref -> ID .)
    LEQ             reduce using rule 32 (varref -> ID .)
    GEQ             reduce using rule 32 (varref -> ID .)
    EQ              reduce using rule 32 (varref -> ID .)
    NEQ             reduce using rule 32 (varref -> ID .)
    OR              reduce using rule 32 (varref -> ID .)
    AND             reduce using rule 32 (varref -> ID .)
    BEGIN           reduce using rule 32 (varref -> ID .)
    THEN            reduce using rule 32 (varref -> ID .)
    RBRACK          reduce using rule 32 (varref -> ID .)
    RPAREN          reduce using rule 32 (varref -> ID .)
    COLON           reduce using rule 32 (varref -> ID .)


state 20

    (19) if_stmt -> IF . l_expr THEN stmt_list ELSE else_stmt
    (34) l_expr -> . l_expr AND l_term
    (35) l_expr -> . l_term
    (36) l_term -> . l_term OR l_fact
    (37) l_term -> . l_fact
    (38) l_fact -> . l_fact oprel a_expr
    (39) l_fact -> . a_expr
    (40) l_fact -> . LPAREN l_expr RPAREN
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . varref
    (25) a_expr -> . NUM
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 37
    SUB             shift and go to state 28
    NUM             shift and go to state 30
    LITERAL_STR     shift and go to state 31
    ID              shift and go to state 19

    l_expr                         shift and go to state 41
    l_term                         shift and go to state 34
    l_fact                         shift and go to state 35
    a_expr                         shift and go to state 36
    varref                         shift and go to state 29

state 21

    (1) program -> stmt_list SEMICOLON .
    (2) stmt_list -> stmt_list SEMICOLON . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    $end            reduce using rule 1 (program -> stmt_list SEMICOLON .)
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt                           shift and go to state 42
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 22

    (12) assignment -> varref ASSIGN . l_expr
    (34) l_expr -> . l_expr AND l_term
    (35) l_expr -> . l_term
    (36) l_term -> . l_term OR l_fact
    (37) l_term -> . l_fact
    (38) l_fact -> . l_fact oprel a_expr
    (39) l_fact -> . a_expr
    (40) l_fact -> . LPAREN l_expr RPAREN
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . varref
    (25) a_expr -> . NUM
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 37
    SUB             shift and go to state 28
    NUM             shift and go to state 30
    LITERAL_STR     shift and go to state 31
    ID              shift and go to state 19

    varref                         shift and go to state 29
    l_expr                         shift and go to state 43
    l_term                         shift and go to state 34
    l_fact                         shift and go to state 35
    a_expr                         shift and go to state 36

state 23

    (33) varref -> varref LBRACK . a_expr RBRACK
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . varref
    (25) a_expr -> . NUM
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    SUB             shift and go to state 28
    NUM             shift and go to state 30
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    varref                         shift and go to state 29
    a_expr                         shift and go to state 44

state 24

    (13) read -> READ varlist .

    SEMICOLON       reduce using rule 13 (read -> READ varlist .)
    UNTIL           reduce using rule 13 (read -> READ varlist .)
    END             reduce using rule 13 (read -> READ varlist .)
    ELSE            reduce using rule 13 (read -> READ varlist .)


state 25

    (47) varlist -> varref .
    (48) varlist -> varref . COMMA varlist
    (33) varref -> varref . LBRACK a_expr RBRACK

    SEMICOLON       reduce using rule 47 (varlist -> varref .)
    UNTIL           reduce using rule 47 (varlist -> varref .)
    END             reduce using rule 47 (varlist -> varref .)
    ELSE            reduce using rule 47 (varlist -> varref .)
    COMMA           shift and go to state 45
    LBRACK          shift and go to state 23


state 26

    (14) write -> WRITE expr_list .
    (50) expr_list -> expr_list . COMMA a_expr

    SEMICOLON       reduce using rule 14 (write -> WRITE expr_list .)
    UNTIL           reduce using rule 14 (write -> WRITE expr_list .)
    END             reduce using rule 14 (write -> WRITE expr_list .)
    ELSE            reduce using rule 14 (write -> WRITE expr_list .)
    COMMA           shift and go to state 46


state 27

    (49) expr_list -> a_expr .
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

    COMMA           reduce using rule 49 (expr_list -> a_expr .)
    SEMICOLON       reduce using rule 49 (expr_list -> a_expr .)
    UNTIL           reduce using rule 49 (expr_list -> a_expr .)
    END             reduce using rule 49 (expr_list -> a_expr .)
    ELSE            reduce using rule 49 (expr_list -> a_expr .)
    ADD             shift and go to state 48
    SUB             shift and go to state 49
    MUL             shift and go to state 50
    DIV             shift and go to state 51

    a_op                           shift and go to state 47

state 28

    (23) a_expr -> SUB . a_expr
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . varref
    (25) a_expr -> . NUM
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    SUB             shift and go to state 28
    NUM             shift and go to state 30
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    a_expr                         shift and go to state 52
    varref                         shift and go to state 29

state 29

    (24) a_expr -> varref .
    (33) varref -> varref . LBRACK a_expr RBRACK

    ADD             reduce using rule 24 (a_expr -> varref .)
    SUB             reduce using rule 24 (a_expr -> varref .)
    MUL             reduce using rule 24 (a_expr -> varref .)
    DIV             reduce using rule 24 (a_expr -> varref .)
    COMMA           reduce using rule 24 (a_expr -> varref .)
    SEMICOLON       reduce using rule 24 (a_expr -> varref .)
    UNTIL           reduce using rule 24 (a_expr -> varref .)
    END             reduce using rule 24 (a_expr -> varref .)
    ELSE            reduce using rule 24 (a_expr -> varref .)
    LT              reduce using rule 24 (a_expr -> varref .)
    GT              reduce using rule 24 (a_expr -> varref .)
    LEQ             reduce using rule 24 (a_expr -> varref .)
    GEQ             reduce using rule 24 (a_expr -> varref .)
    EQ              reduce using rule 24 (a_expr -> varref .)
    NEQ             reduce using rule 24 (a_expr -> varref .)
    OR              reduce using rule 24 (a_expr -> varref .)
    AND             reduce using rule 24 (a_expr -> varref .)
    BEGIN           reduce using rule 24 (a_expr -> varref .)
    THEN            reduce using rule 24 (a_expr -> varref .)
    RBRACK          reduce using rule 24 (a_expr -> varref .)
    RPAREN          reduce using rule 24 (a_expr -> varref .)
    COLON           reduce using rule 24 (a_expr -> varref .)
    LBRACK          shift and go to state 23


state 30

    (25) a_expr -> NUM .

    ADD             reduce using rule 25 (a_expr -> NUM .)
    SUB             reduce using rule 25 (a_expr -> NUM .)
    MUL             reduce using rule 25 (a_expr -> NUM .)
    DIV             reduce using rule 25 (a_expr -> NUM .)
    COMMA           reduce using rule 25 (a_expr -> NUM .)
    SEMICOLON       reduce using rule 25 (a_expr -> NUM .)
    UNTIL           reduce using rule 25 (a_expr -> NUM .)
    END             reduce using rule 25 (a_expr -> NUM .)
    ELSE            reduce using rule 25 (a_expr -> NUM .)
    LT              reduce using rule 25 (a_expr -> NUM .)
    GT              reduce using rule 25 (a_expr -> NUM .)
    LEQ             reduce using rule 25 (a_expr -> NUM .)
    GEQ             reduce using rule 25 (a_expr -> NUM .)
    EQ              reduce using rule 25 (a_expr -> NUM .)
    NEQ             reduce using rule 25 (a_expr -> NUM .)
    OR              reduce using rule 25 (a_expr -> NUM .)
    AND             reduce using rule 25 (a_expr -> NUM .)
    BEGIN           reduce using rule 25 (a_expr -> NUM .)
    THEN            reduce using rule 25 (a_expr -> NUM .)
    RBRACK          reduce using rule 25 (a_expr -> NUM .)
    RPAREN          reduce using rule 25 (a_expr -> NUM .)
    COLON           reduce using rule 25 (a_expr -> NUM .)


state 31

    (26) a_expr -> LITERAL_STR .

    ADD             reduce using rule 26 (a_expr -> LITERAL_STR .)
    SUB             reduce using rule 26 (a_expr -> LITERAL_STR .)
    MUL             reduce using rule 26 (a_expr -> LITERAL_STR .)
    DIV             reduce using rule 26 (a_expr -> LITERAL_STR .)
    COMMA           reduce using rule 26 (a_expr -> LITERAL_STR .)
    SEMICOLON       reduce using rule 26 (a_expr -> LITERAL_STR .)
    UNTIL           reduce using rule 26 (a_expr -> LITERAL_STR .)
    END             reduce using rule 26 (a_expr -> LITERAL_STR .)
    ELSE            reduce using rule 26 (a_expr -> LITERAL_STR .)
    LT              reduce using rule 26 (a_expr -> LITERAL_STR .)
    GT              reduce using rule 26 (a_expr -> LITERAL_STR .)
    LEQ             reduce using rule 26 (a_expr -> LITERAL_STR .)
    GEQ             reduce using rule 26 (a_expr -> LITERAL_STR .)
    EQ              reduce using rule 26 (a_expr -> LITERAL_STR .)
    NEQ             reduce using rule 26 (a_expr -> LITERAL_STR .)
    OR              reduce using rule 26 (a_expr -> LITERAL_STR .)
    AND             reduce using rule 26 (a_expr -> LITERAL_STR .)
    BEGIN           reduce using rule 26 (a_expr -> LITERAL_STR .)
    THEN            reduce using rule 26 (a_expr -> LITERAL_STR .)
    RBRACK          reduce using rule 26 (a_expr -> LITERAL_STR .)
    RPAREN          reduce using rule 26 (a_expr -> LITERAL_STR .)
    COLON           reduce using rule 26 (a_expr -> LITERAL_STR .)


state 32

    (27) a_expr -> LPAREN . a_expr RPAREN
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . varref
    (25) a_expr -> . NUM
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    SUB             shift and go to state 28
    NUM             shift and go to state 30
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    a_expr                         shift and go to state 53
    varref                         shift and go to state 29

state 33

    (15) while -> WHILE l_expr . block
    (34) l_expr -> l_expr . AND l_term
    (17) block -> . BEGIN stmt_list END

    AND             shift and go to state 55
    BEGIN           shift and go to state 17

    block                          shift and go to state 54

state 34

    (35) l_expr -> l_term .
    (36) l_term -> l_term . OR l_fact

    AND             reduce using rule 35 (l_expr -> l_term .)
    BEGIN           reduce using rule 35 (l_expr -> l_term .)
    THEN            reduce using rule 35 (l_expr -> l_term .)
    SEMICOLON       reduce using rule 35 (l_expr -> l_term .)
    UNTIL           reduce using rule 35 (l_expr -> l_term .)
    END             reduce using rule 35 (l_expr -> l_term .)
    ELSE            reduce using rule 35 (l_expr -> l_term .)
    RPAREN          reduce using rule 35 (l_expr -> l_term .)
    OR              shift and go to state 56


state 35

    (37) l_term -> l_fact .
    (38) l_fact -> l_fact . oprel a_expr
    (41) oprel -> . LT
    (42) oprel -> . GT
    (43) oprel -> . LEQ
    (44) oprel -> . GEQ
    (45) oprel -> . EQ
    (46) oprel -> . NEQ

    OR              reduce using rule 37 (l_term -> l_fact .)
    AND             reduce using rule 37 (l_term -> l_fact .)
    BEGIN           reduce using rule 37 (l_term -> l_fact .)
    THEN            reduce using rule 37 (l_term -> l_fact .)
    SEMICOLON       reduce using rule 37 (l_term -> l_fact .)
    UNTIL           reduce using rule 37 (l_term -> l_fact .)
    END             reduce using rule 37 (l_term -> l_fact .)
    ELSE            reduce using rule 37 (l_term -> l_fact .)
    RPAREN          reduce using rule 37 (l_term -> l_fact .)
    LT              shift and go to state 58
    GT              shift and go to state 59
    LEQ             shift and go to state 60
    GEQ             shift and go to state 61
    EQ              shift and go to state 62
    NEQ             shift and go to state 63

    oprel                          shift and go to state 57

state 36

    (39) l_fact -> a_expr .
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

    LT              reduce using rule 39 (l_fact -> a_expr .)
    GT              reduce using rule 39 (l_fact -> a_expr .)
    LEQ             reduce using rule 39 (l_fact -> a_expr .)
    GEQ             reduce using rule 39 (l_fact -> a_expr .)
    EQ              reduce using rule 39 (l_fact -> a_expr .)
    NEQ             reduce using rule 39 (l_fact -> a_expr .)
    OR              reduce using rule 39 (l_fact -> a_expr .)
    AND             reduce using rule 39 (l_fact -> a_expr .)
    BEGIN           reduce using rule 39 (l_fact -> a_expr .)
    THEN            reduce using rule 39 (l_fact -> a_expr .)
    SEMICOLON       reduce using rule 39 (l_fact -> a_expr .)
    UNTIL           reduce using rule 39 (l_fact -> a_expr .)
    END             reduce using rule 39 (l_fact -> a_expr .)
    ELSE            reduce using rule 39 (l_fact -> a_expr .)
    RPAREN          reduce using rule 39 (l_fact -> a_expr .)
    ADD             shift and go to state 48
    SUB             shift and go to state 49
    MUL             shift and go to state 50
    DIV             shift and go to state 51

    a_op                           shift and go to state 47

state 37

    (40) l_fact -> LPAREN . l_expr RPAREN
    (27) a_expr -> LPAREN . a_expr RPAREN
    (34) l_expr -> . l_expr AND l_term
    (35) l_expr -> . l_term
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . varref
    (25) a_expr -> . NUM
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (36) l_term -> . l_term OR l_fact
    (37) l_term -> . l_fact
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK
    (38) l_fact -> . l_fact oprel a_expr
    (39) l_fact -> . a_expr
    (40) l_fact -> . LPAREN l_expr RPAREN

    SUB             shift and go to state 28
    NUM             shift and go to state 30
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 64
    ID              shift and go to state 19

    l_expr                         shift and go to state 65
    a_expr                         shift and go to state 66
    l_term                         shift and go to state 34
    varref                         shift and go to state 29
    l_fact                         shift and go to state 35

state 38

    (16) repeat -> REPEAT stmt_list . UNTIL l_expr
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    UNTIL           shift and go to state 67
    SEMICOLON       shift and go to state 68


state 39

    (17) block -> BEGIN stmt_list . END
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    END             shift and go to state 69
    SEMICOLON       shift and go to state 68


state 40

    (18) foreach -> FOREACH ID . IN LPAREN a_expr COLON a_expr RPAREN stmt

    IN              shift and go to state 70


state 41

    (19) if_stmt -> IF l_expr . THEN stmt_list ELSE else_stmt
    (34) l_expr -> l_expr . AND l_term

    THEN            shift and go to state 71
    AND             shift and go to state 55


state 42

    (2) stmt_list -> stmt_list SEMICOLON stmt .

    SEMICOLON       reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)
    UNTIL           reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)
    END             reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)
    ELSE            reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)


state 43

    (12) assignment -> varref ASSIGN l_expr .
    (34) l_expr -> l_expr . AND l_term

    SEMICOLON       reduce using rule 12 (assignment -> varref ASSIGN l_expr .)
    UNTIL           reduce using rule 12 (assignment -> varref ASSIGN l_expr .)
    END             reduce using rule 12 (assignment -> varref ASSIGN l_expr .)
    ELSE            reduce using rule 12 (assignment -> varref ASSIGN l_expr .)
    AND             shift and go to state 55


state 44

    (33) varref -> varref LBRACK a_expr . RBRACK
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

    RBRACK          shift and go to state 72
    ADD             shift and go to state 48
    SUB             shift and go to state 49
    MUL             shift and go to state 50
    DIV             shift and go to state 51

    a_op                           shift and go to state 47

state 45

    (48) varlist -> varref COMMA . varlist
    (47) varlist -> . varref
    (48) varlist -> . varref COMMA varlist
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    ID              shift and go to state 19

    varref                         shift and go to state 25
    varlist                        shift and go to state 73

state 46

    (50) expr_list -> expr_list COMMA . a_expr
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . varref
    (25) a_expr -> . NUM
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    SUB             shift and go to state 28
    NUM             shift and go to state 30
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    a_expr                         shift and go to state 74
    varref                         shift and go to state 29

state 47

    (22) a_expr -> a_expr a_op . a_expr
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . varref
    (25) a_expr -> . NUM
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    SUB             shift and go to state 28
    NUM             shift and go to state 30
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    a_expr                         shift and go to state 75
    varref                         shift and go to state 29

state 48

    (28) a_op -> ADD .

    SUB             reduce using rule 28 (a_op -> ADD .)
    NUM             reduce using rule 28 (a_op -> ADD .)
    LITERAL_STR     reduce using rule 28 (a_op -> ADD .)
    LPAREN          reduce using rule 28 (a_op -> ADD .)
    ID              reduce using rule 28 (a_op -> ADD .)


state 49

    (29) a_op -> SUB .

    SUB             reduce using rule 29 (a_op -> SUB .)
    NUM             reduce using rule 29 (a_op -> SUB .)
    LITERAL_STR     reduce using rule 29 (a_op -> SUB .)
    LPAREN          reduce using rule 29 (a_op -> SUB .)
    ID              reduce using rule 29 (a_op -> SUB .)


state 50

    (30) a_op -> MUL .

    SUB             reduce using rule 30 (a_op -> MUL .)
    NUM             reduce using rule 30 (a_op -> MUL .)
    LITERAL_STR     reduce using rule 30 (a_op -> MUL .)
    LPAREN          reduce using rule 30 (a_op -> MUL .)
    ID              reduce using rule 30 (a_op -> MUL .)


state 51

    (31) a_op -> DIV .

    SUB             reduce using rule 31 (a_op -> DIV .)
    NUM             reduce using rule 31 (a_op -> DIV .)
    LITERAL_STR     reduce using rule 31 (a_op -> DIV .)
    LPAREN          reduce using rule 31 (a_op -> DIV .)
    ID              reduce using rule 31 (a_op -> DIV .)


state 52

    (23) a_expr -> SUB a_expr .
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    COMMA           reduce using rule 23 (a_expr -> SUB a_expr .)
    SEMICOLON       reduce using rule 23 (a_expr -> SUB a_expr .)
    UNTIL           reduce using rule 23 (a_expr -> SUB a_expr .)
    END             reduce using rule 23 (a_expr -> SUB a_expr .)
    ELSE            reduce using rule 23 (a_expr -> SUB a_expr .)
    LT              reduce using rule 23 (a_expr -> SUB a_expr .)
    GT              reduce using rule 23 (a_expr -> SUB a_expr .)
    LEQ             reduce using rule 23 (a_expr -> SUB a_expr .)
    GEQ             reduce using rule 23 (a_expr -> SUB a_expr .)
    EQ              reduce using rule 23 (a_expr -> SUB a_expr .)
    NEQ             reduce using rule 23 (a_expr -> SUB a_expr .)
    OR              reduce using rule 23 (a_expr -> SUB a_expr .)
    AND             reduce using rule 23 (a_expr -> SUB a_expr .)
    BEGIN           reduce using rule 23 (a_expr -> SUB a_expr .)
    THEN            reduce using rule 23 (a_expr -> SUB a_expr .)
    RBRACK          reduce using rule 23 (a_expr -> SUB a_expr .)
    RPAREN          reduce using rule 23 (a_expr -> SUB a_expr .)
    COLON           reduce using rule 23 (a_expr -> SUB a_expr .)
    ADD             shift and go to state 48
    SUB             shift and go to state 49
    MUL             shift and go to state 50
    DIV             shift and go to state 51

  ! ADD             [ reduce using rule 23 (a_expr -> SUB a_expr .) ]
  ! SUB             [ reduce using rule 23 (a_expr -> SUB a_expr .) ]
  ! MUL             [ reduce using rule 23 (a_expr -> SUB a_expr .) ]
  ! DIV             [ reduce using rule 23 (a_expr -> SUB a_expr .) ]

    a_op                           shift and go to state 47

state 53

    (27) a_expr -> LPAREN a_expr . RPAREN
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

    RPAREN          shift and go to state 76
    ADD             shift and go to state 48
    SUB             shift and go to state 49
    MUL             shift and go to state 50
    DIV             shift and go to state 51

    a_op                           shift and go to state 47

state 54

    (15) while -> WHILE l_expr block .

    SEMICOLON       reduce using rule 15 (while -> WHILE l_expr block .)
    UNTIL           reduce using rule 15 (while -> WHILE l_expr block .)
    END             reduce using rule 15 (while -> WHILE l_expr block .)
    ELSE            reduce using rule 15 (while -> WHILE l_expr block .)


state 55

    (34) l_expr -> l_expr AND . l_term
    (36) l_term -> . l_term OR l_fact
    (37) l_term -> . l_fact
    (38) l_fact -> . l_fact oprel a_expr
    (39) l_fact -> . a_expr
    (40) l_fact -> . LPAREN l_expr RPAREN
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . varref
    (25) a_expr -> . NUM
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 37
    SUB             shift and go to state 28
    NUM             shift and go to state 30
    LITERAL_STR     shift and go to state 31
    ID              shift and go to state 19

    l_term                         shift and go to state 77
    l_fact                         shift and go to state 35
    a_expr                         shift and go to state 36
    varref                         shift and go to state 29

state 56

    (36) l_term -> l_term OR . l_fact
    (38) l_fact -> . l_fact oprel a_expr
    (39) l_fact -> . a_expr
    (40) l_fact -> . LPAREN l_expr RPAREN
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . varref
    (25) a_expr -> . NUM
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 37
    SUB             shift and go to state 28
    NUM             shift and go to state 30
    LITERAL_STR     shift and go to state 31
    ID              shift and go to state 19

    l_fact                         shift and go to state 78
    a_expr                         shift and go to state 36
    varref                         shift and go to state 29

state 57

    (38) l_fact -> l_fact oprel . a_expr
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . varref
    (25) a_expr -> . NUM
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    SUB             shift and go to state 28
    NUM             shift and go to state 30
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    a_expr                         shift and go to state 79
    varref                         shift and go to state 29

state 58

    (41) oprel -> LT .

    SUB             reduce using rule 41 (oprel -> LT .)
    NUM             reduce using rule 41 (oprel -> LT .)
    LITERAL_STR     reduce using rule 41 (oprel -> LT .)
    LPAREN          reduce using rule 41 (oprel -> LT .)
    ID              reduce using rule 41 (oprel -> LT .)


state 59

    (42) oprel -> GT .

    SUB             reduce using rule 42 (oprel -> GT .)
    NUM             reduce using rule 42 (oprel -> GT .)
    LITERAL_STR     reduce using rule 42 (oprel -> GT .)
    LPAREN          reduce using rule 42 (oprel -> GT .)
    ID              reduce using rule 42 (oprel -> GT .)


state 60

    (43) oprel -> LEQ .

    SUB             reduce using rule 43 (oprel -> LEQ .)
    NUM             reduce using rule 43 (oprel -> LEQ .)
    LITERAL_STR     reduce using rule 43 (oprel -> LEQ .)
    LPAREN          reduce using rule 43 (oprel -> LEQ .)
    ID              reduce using rule 43 (oprel -> LEQ .)


state 61

    (44) oprel -> GEQ .

    SUB             reduce using rule 44 (oprel -> GEQ .)
    NUM             reduce using rule 44 (oprel -> GEQ .)
    LITERAL_STR     reduce using rule 44 (oprel -> GEQ .)
    LPAREN          reduce using rule 44 (oprel -> GEQ .)
    ID              reduce using rule 44 (oprel -> GEQ .)


state 62

    (45) oprel -> EQ .

    SUB             reduce using rule 45 (oprel -> EQ .)
    NUM             reduce using rule 45 (oprel -> EQ .)
    LITERAL_STR     reduce using rule 45 (oprel -> EQ .)
    LPAREN          reduce using rule 45 (oprel -> EQ .)
    ID              reduce using rule 45 (oprel -> EQ .)


state 63

    (46) oprel -> NEQ .

    SUB             reduce using rule 46 (oprel -> NEQ .)
    NUM             reduce using rule 46 (oprel -> NEQ .)
    LITERAL_STR     reduce using rule 46 (oprel -> NEQ .)
    LPAREN          reduce using rule 46 (oprel -> NEQ .)
    ID              reduce using rule 46 (oprel -> NEQ .)


state 64

    (27) a_expr -> LPAREN . a_expr RPAREN
    (40) l_fact -> LPAREN . l_expr RPAREN
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . varref
    (25) a_expr -> . NUM
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (34) l_expr -> . l_expr AND l_term
    (35) l_expr -> . l_term
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK
    (36) l_term -> . l_term OR l_fact
    (37) l_term -> . l_fact
    (38) l_fact -> . l_fact oprel a_expr
    (39) l_fact -> . a_expr
    (40) l_fact -> . LPAREN l_expr RPAREN

    SUB             shift and go to state 28
    NUM             shift and go to state 30
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 64
    ID              shift and go to state 19

    a_expr                         shift and go to state 66
    l_expr                         shift and go to state 65
    varref                         shift and go to state 29
    l_term                         shift and go to state 34
    l_fact                         shift and go to state 35

state 65

    (40) l_fact -> LPAREN l_expr . RPAREN
    (34) l_expr -> l_expr . AND l_term

    RPAREN          shift and go to state 80
    AND             shift and go to state 55


state 66

    (27) a_expr -> LPAREN a_expr . RPAREN
    (22) a_expr -> a_expr . a_op a_expr
    (39) l_fact -> a_expr .
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 76
    LT              reduce using rule 39 (l_fact -> a_expr .)
    GT              reduce using rule 39 (l_fact -> a_expr .)
    LEQ             reduce using rule 39 (l_fact -> a_expr .)
    GEQ             reduce using rule 39 (l_fact -> a_expr .)
    EQ              reduce using rule 39 (l_fact -> a_expr .)
    NEQ             reduce using rule 39 (l_fact -> a_expr .)
    OR              reduce using rule 39 (l_fact -> a_expr .)
    AND             reduce using rule 39 (l_fact -> a_expr .)
    ADD             shift and go to state 48
    SUB             shift and go to state 49
    MUL             shift and go to state 50
    DIV             shift and go to state 51

  ! RPAREN          [ reduce using rule 39 (l_fact -> a_expr .) ]

    a_op                           shift and go to state 47

state 67

    (16) repeat -> REPEAT stmt_list UNTIL . l_expr
    (34) l_expr -> . l_expr AND l_term
    (35) l_expr -> . l_term
    (36) l_term -> . l_term OR l_fact
    (37) l_term -> . l_fact
    (38) l_fact -> . l_fact oprel a_expr
    (39) l_fact -> . a_expr
    (40) l_fact -> . LPAREN l_expr RPAREN
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . varref
    (25) a_expr -> . NUM
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 37
    SUB             shift and go to state 28
    NUM             shift and go to state 30
    LITERAL_STR     shift and go to state 31
    ID              shift and go to state 19

    l_expr                         shift and go to state 81
    l_term                         shift and go to state 34
    l_fact                         shift and go to state 35
    a_expr                         shift and go to state 36
    varref                         shift and go to state 29

state 68

    (2) stmt_list -> stmt_list SEMICOLON . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt                           shift and go to state 42
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 69

    (17) block -> BEGIN stmt_list END .

    SEMICOLON       reduce using rule 17 (block -> BEGIN stmt_list END .)
    UNTIL           reduce using rule 17 (block -> BEGIN stmt_list END .)
    END             reduce using rule 17 (block -> BEGIN stmt_list END .)
    ELSE            reduce using rule 17 (block -> BEGIN stmt_list END .)


state 70

    (18) foreach -> FOREACH ID IN . LPAREN a_expr COLON a_expr RPAREN stmt

    LPAREN          shift and go to state 82


state 71

    (19) if_stmt -> IF l_expr THEN . stmt_list ELSE else_stmt
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt_list                      shift and go to state 83
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 72

    (33) varref -> varref LBRACK a_expr RBRACK .

    ASSIGN          reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    LBRACK          reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    COMMA           reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    SEMICOLON       reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    UNTIL           reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    END             reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    ELSE            reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    ADD             reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    SUB             reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    MUL             reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    DIV             reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    LT              reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    GT              reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    LEQ             reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    GEQ             reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    EQ              reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    NEQ             reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    OR              reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    AND             reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    BEGIN           reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    THEN            reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    RBRACK          reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    RPAREN          reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)
    COLON           reduce using rule 33 (varref -> varref LBRACK a_expr RBRACK .)


state 73

    (48) varlist -> varref COMMA varlist .

    SEMICOLON       reduce using rule 48 (varlist -> varref COMMA varlist .)
    UNTIL           reduce using rule 48 (varlist -> varref COMMA varlist .)
    END             reduce using rule 48 (varlist -> varref COMMA varlist .)
    ELSE            reduce using rule 48 (varlist -> varref COMMA varlist .)


state 74

    (50) expr_list -> expr_list COMMA a_expr .
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

    COMMA           reduce using rule 50 (expr_list -> expr_list COMMA a_expr .)
    SEMICOLON       reduce using rule 50 (expr_list -> expr_list COMMA a_expr .)
    UNTIL           reduce using rule 50 (expr_list -> expr_list COMMA a_expr .)
    END             reduce using rule 50 (expr_list -> expr_list COMMA a_expr .)
    ELSE            reduce using rule 50 (expr_list -> expr_list COMMA a_expr .)
    ADD             shift and go to state 48
    SUB             shift and go to state 49
    MUL             shift and go to state 50
    DIV             shift and go to state 51

    a_op                           shift and go to state 47

state 75

    (22) a_expr -> a_expr a_op a_expr .
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    COMMA           reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    SEMICOLON       reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    UNTIL           reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    END             reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    ELSE            reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    LT              reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    GT              reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    LEQ             reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    GEQ             reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    EQ              reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    NEQ             reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    OR              reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    AND             reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    BEGIN           reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    THEN            reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    RBRACK          reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    RPAREN          reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    COLON           reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    ADD             shift and go to state 48
    SUB             shift and go to state 49
    MUL             shift and go to state 50
    DIV             shift and go to state 51

  ! ADD             [ reduce using rule 22 (a_expr -> a_expr a_op a_expr .) ]
  ! SUB             [ reduce using rule 22 (a_expr -> a_expr a_op a_expr .) ]
  ! MUL             [ reduce using rule 22 (a_expr -> a_expr a_op a_expr .) ]
  ! DIV             [ reduce using rule 22 (a_expr -> a_expr a_op a_expr .) ]

    a_op                           shift and go to state 47

state 76

    (27) a_expr -> LPAREN a_expr RPAREN .

    ADD             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    SUB             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    MUL             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    DIV             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    COMMA           reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    SEMICOLON       reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    UNTIL           reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    END             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    ELSE            reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    LT              reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    GT              reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    LEQ             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    GEQ             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    EQ              reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    NEQ             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    OR              reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    AND             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    BEGIN           reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    THEN            reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    RBRACK          reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    RPAREN          reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    COLON           reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)


state 77

    (34) l_expr -> l_expr AND l_term .
    (36) l_term -> l_term . OR l_fact

    AND             reduce using rule 34 (l_expr -> l_expr AND l_term .)
    BEGIN           reduce using rule 34 (l_expr -> l_expr AND l_term .)
    THEN            reduce using rule 34 (l_expr -> l_expr AND l_term .)
    SEMICOLON       reduce using rule 34 (l_expr -> l_expr AND l_term .)
    UNTIL           reduce using rule 34 (l_expr -> l_expr AND l_term .)
    END             reduce using rule 34 (l_expr -> l_expr AND l_term .)
    ELSE            reduce using rule 34 (l_expr -> l_expr AND l_term .)
    RPAREN          reduce using rule 34 (l_expr -> l_expr AND l_term .)
    OR              shift and go to state 56


state 78

    (36) l_term -> l_term OR l_fact .
    (38) l_fact -> l_fact . oprel a_expr
    (41) oprel -> . LT
    (42) oprel -> . GT
    (43) oprel -> . LEQ
    (44) oprel -> . GEQ
    (45) oprel -> . EQ
    (46) oprel -> . NEQ

    OR              reduce using rule 36 (l_term -> l_term OR l_fact .)
    AND             reduce using rule 36 (l_term -> l_term OR l_fact .)
    BEGIN           reduce using rule 36 (l_term -> l_term OR l_fact .)
    THEN            reduce using rule 36 (l_term -> l_term OR l_fact .)
    SEMICOLON       reduce using rule 36 (l_term -> l_term OR l_fact .)
    UNTIL           reduce using rule 36 (l_term -> l_term OR l_fact .)
    END             reduce using rule 36 (l_term -> l_term OR l_fact .)
    ELSE            reduce using rule 36 (l_term -> l_term OR l_fact .)
    RPAREN          reduce using rule 36 (l_term -> l_term OR l_fact .)
    LT              shift and go to state 58
    GT              shift and go to state 59
    LEQ             shift and go to state 60
    GEQ             shift and go to state 61
    EQ              shift and go to state 62
    NEQ             shift and go to state 63

    oprel                          shift and go to state 57

state 79

    (38) l_fact -> l_fact oprel a_expr .
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

    LT              reduce using rule 38 (l_fact -> l_fact oprel a_expr .)
    GT              reduce using rule 38 (l_fact -> l_fact oprel a_expr .)
    LEQ             reduce using rule 38 (l_fact -> l_fact oprel a_expr .)
    GEQ             reduce using rule 38 (l_fact -> l_fact oprel a_expr .)
    EQ              reduce using rule 38 (l_fact -> l_fact oprel a_expr .)
    NEQ             reduce using rule 38 (l_fact -> l_fact oprel a_expr .)
    OR              reduce using rule 38 (l_fact -> l_fact oprel a_expr .)
    AND             reduce using rule 38 (l_fact -> l_fact oprel a_expr .)
    BEGIN           reduce using rule 38 (l_fact -> l_fact oprel a_expr .)
    THEN            reduce using rule 38 (l_fact -> l_fact oprel a_expr .)
    SEMICOLON       reduce using rule 38 (l_fact -> l_fact oprel a_expr .)
    UNTIL           reduce using rule 38 (l_fact -> l_fact oprel a_expr .)
    END             reduce using rule 38 (l_fact -> l_fact oprel a_expr .)
    ELSE            reduce using rule 38 (l_fact -> l_fact oprel a_expr .)
    RPAREN          reduce using rule 38 (l_fact -> l_fact oprel a_expr .)
    ADD             shift and go to state 48
    SUB             shift and go to state 49
    MUL             shift and go to state 50
    DIV             shift and go to state 51

    a_op                           shift and go to state 47

state 80

    (40) l_fact -> LPAREN l_expr RPAREN .

    LT              reduce using rule 40 (l_fact -> LPAREN l_expr RPAREN .)
    GT              reduce using rule 40 (l_fact -> LPAREN l_expr RPAREN .)
    LEQ             reduce using rule 40 (l_fact -> LPAREN l_expr RPAREN .)
    GEQ             reduce using rule 40 (l_fact -> LPAREN l_expr RPAREN .)
    EQ              reduce using rule 40 (l_fact -> LPAREN l_expr RPAREN .)
    NEQ             reduce using rule 40 (l_fact -> LPAREN l_expr RPAREN .)
    OR              reduce using rule 40 (l_fact -> LPAREN l_expr RPAREN .)
    AND             reduce using rule 40 (l_fact -> LPAREN l_expr RPAREN .)
    BEGIN           reduce using rule 40 (l_fact -> LPAREN l_expr RPAREN .)
    THEN            reduce using rule 40 (l_fact -> LPAREN l_expr RPAREN .)
    SEMICOLON       reduce using rule 40 (l_fact -> LPAREN l_expr RPAREN .)
    UNTIL           reduce using rule 40 (l_fact -> LPAREN l_expr RPAREN .)
    END             reduce using rule 40 (l_fact -> LPAREN l_expr RPAREN .)
    ELSE            reduce using rule 40 (l_fact -> LPAREN l_expr RPAREN .)
    RPAREN          reduce using rule 40 (l_fact -> LPAREN l_expr RPAREN .)


state 81

    (16) repeat -> REPEAT stmt_list UNTIL l_expr .
    (34) l_expr -> l_expr . AND l_term

    SEMICOLON       reduce using rule 16 (repeat -> REPEAT stmt_list UNTIL l_expr .)
    UNTIL           reduce using rule 16 (repeat -> REPEAT stmt_list UNTIL l_expr .)
    END             reduce using rule 16 (repeat -> REPEAT stmt_list UNTIL l_expr .)
    ELSE            reduce using rule 16 (repeat -> REPEAT stmt_list UNTIL l_expr .)
    AND             shift and go to state 55


state 82

    (18) foreach -> FOREACH ID IN LPAREN . a_expr COLON a_expr RPAREN stmt
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . varref
    (25) a_expr -> . NUM
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    SUB             shift and go to state 28
    NUM             shift and go to state 30
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    a_expr                         shift and go to state 84
    varref                         shift and go to state 29

state 83

    (19) if_stmt -> IF l_expr THEN stmt_list . ELSE else_stmt
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    ELSE            shift and go to state 85
    SEMICOLON       shift and go to state 68


state 84

    (18) foreach -> FOREACH ID IN LPAREN a_expr . COLON a_expr RPAREN stmt
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

    COLON           shift and go to state 86
    ADD             shift and go to state 48
    SUB             shift and go to state 49
    MUL             shift and go to state 50
    DIV             shift and go to state 51

    a_op                           shift and go to state 47

state 85

    (19) if_stmt -> IF l_expr THEN stmt_list ELSE . else_stmt
    (20) else_stmt -> .
    (21) else_stmt -> . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 20 (else_stmt -> .)
    UNTIL           reduce using rule 20 (else_stmt -> .)
    END             reduce using rule 20 (else_stmt -> .)
    ELSE            shift and go to state 87

  ! ELSE            [ reduce using rule 20 (else_stmt -> .) ]

    else_stmt                      shift and go to state 88

state 86

    (18) foreach -> FOREACH ID IN LPAREN a_expr COLON . a_expr RPAREN stmt
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . varref
    (25) a_expr -> . NUM
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    SUB             shift and go to state 28
    NUM             shift and go to state 30
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    a_expr                         shift and go to state 89
    varref                         shift and go to state 29

state 87

    (21) else_stmt -> ELSE . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt                           shift and go to state 90
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 88

    (19) if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt .

    SEMICOLON       reduce using rule 19 (if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt .)
    UNTIL           reduce using rule 19 (if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt .)
    END             reduce using rule 19 (if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt .)
    ELSE            reduce using rule 19 (if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt .)


state 89

    (18) foreach -> FOREACH ID IN LPAREN a_expr COLON a_expr . RPAREN stmt
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

    RPAREN          shift and go to state 91
    ADD             shift and go to state 48
    SUB             shift and go to state 49
    MUL             shift and go to state 50
    DIV             shift and go to state 51

    a_op                           shift and go to state 47

state 90

    (21) else_stmt -> ELSE stmt .

    SEMICOLON       reduce using rule 21 (else_stmt -> ELSE stmt .)
    UNTIL           reduce using rule 21 (else_stmt -> ELSE stmt .)
    END             reduce using rule 21 (else_stmt -> ELSE stmt .)
    ELSE            reduce using rule 21 (else_stmt -> ELSE stmt .)


state 91

    (18) foreach -> FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (32) varref -> . ID
    (33) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt                           shift and go to state 92
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 92

    (18) foreach -> FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt .

    SEMICOLON       reduce using rule 18 (foreach -> FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt .)
    UNTIL           reduce using rule 18 (foreach -> FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt .)
    END             reduce using rule 18 (foreach -> FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt .)
    ELSE            reduce using rule 18 (foreach -> FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ADD in state 52 resolved as shift
WARNING: shift/reduce conflict for SUB in state 52 resolved as shift
WARNING: shift/reduce conflict for MUL in state 52 resolved as shift
WARNING: shift/reduce conflict for DIV in state 52 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 66 resolved as shift
WARNING: shift/reduce conflict for ADD in state 75 resolved as shift
WARNING: shift/reduce conflict for SUB in state 75 resolved as shift
WARNING: shift/reduce conflict for MUL in state 75 resolved as shift
WARNING: shift/reduce conflict for DIV in state 75 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 85 resolved as shift
