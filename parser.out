Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt_list SEMICOLON
Rule 2     stmt_list -> stmt_list SEMICOLON stmt
Rule 3     stmt_list -> stmt
Rule 4     stmt -> assignment
Rule 5     stmt -> read
Rule 6     stmt -> write
Rule 7     stmt -> while
Rule 8     stmt -> repeat
Rule 9     stmt -> block
Rule 10    stmt -> foreach
Rule 11    stmt -> if_stmt
Rule 12    block -> BEGIN stmt_list END
Rule 13    foreach -> FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
Rule 14    while -> WHILE l_expr block
Rule 15    repeat -> REPEAT stmt_list UNTIL l_expr
Rule 16    if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt
Rule 17    else_stmt -> <empty>
Rule 18    else_stmt -> ELSE stmt
Rule 19    assignment -> varref ASSIGN l_expr
Rule 20    a_expr -> a_expr ADD a_term
Rule 21    a_expr -> a_expr SUB a_term
Rule 22    a_expr -> a_term
Rule 23    a_term -> a_term MUL a_fact
Rule 24    a_term -> a_term DIV a_fact
Rule 25    a_term -> a_fact
Rule 26    a_fact -> varref
Rule 27    a_fact -> NUM
Rule 28    a_fact -> LITERAL_STR
Rule 29    a_fact -> SUB a_fact
Rule 30    a_fact -> LPAREN a_expr RPAREN
Rule 31    varref -> ID
Rule 32    varref -> varref LBRACK a_expr RBRACK
Rule 33    l_expr -> l_expr AND l_term
Rule 34    l_expr -> l_term
Rule 35    l_term -> l_term OR l_fact
Rule 36    l_term -> l_fact
Rule 37    l_fact -> l_fact oprel a_expr
Rule 38    l_fact -> a_expr
Rule 39    l_fact -> LPAREN l_expr RPAREN
Rule 40    oprel -> LT
Rule 41    oprel -> GT
Rule 42    oprel -> LEQ
Rule 43    oprel -> GEQ
Rule 44    oprel -> EQ
Rule 45    oprel -> NEQ
Rule 46    read -> READ varlist
Rule 47    write -> WRITE expr_list
Rule 48    varlist -> varref
Rule 49    varlist -> varref COMMA_DELIM varlist
Rule 50    expr_list -> a_expr
Rule 51    expr_list -> expr_list COMMA_DELIM a_expr

Terminals, with rules where they appear

ADD                  : 20
AND                  : 33
ASSIGN               : 19
BEGIN                : 12
COLON                : 13
COMMA_DELIM          : 49 51
DIV                  : 24
ELSE                 : 16 18
END                  : 12
EQ                   : 44
FOREACH              : 13
GEQ                  : 43
GT                   : 41
ID                   : 13 31
IF                   : 16
IN                   : 13
LBRACK               : 32
LEQ                  : 42
LITERAL_STR          : 28
LPAREN               : 13 30 39
LT                   : 40
MUL                  : 23
NEQ                  : 45
NUM                  : 27
OR                   : 35
RBRACK               : 32
READ                 : 46
REPEAT               : 15
RPAREN               : 13 30 39
SEMICOLON            : 1 2
SUB                  : 21 29
THEN                 : 16
UNTIL                : 15
WHILE                : 14
WRITE                : 47
error                : 

Nonterminals, with rules where they appear

a_expr               : 20 21 30 32 37 38 50 51
a_fact               : 13 13 23 24 25 29
a_term               : 20 21 22 23 24
assignment           : 4
block                : 9 14
else_stmt            : 16
expr_list            : 47 51
foreach              : 10
if_stmt              : 11
l_expr               : 14 15 16 19 33 39
l_fact               : 35 36 37
l_term               : 33 34 35
oprel                : 37
program              : 0
read                 : 5
repeat               : 8
stmt                 : 2 3 13 18
stmt_list            : 1 2 12 15 16
varlist              : 46 49
varref               : 19 26 32 48 49
while                : 7
write                : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt_list SEMICOLON
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (19) assignment -> . varref ASSIGN l_expr
    (46) read -> . READ varlist
    (47) write -> . WRITE expr_list
    (14) while -> . WHILE l_expr block
    (15) repeat -> . REPEAT stmt_list UNTIL l_expr
    (12) block -> . BEGIN stmt_list END
    (13) foreach -> . FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
    (16) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt_list . SEMICOLON
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    SEMICOLON       shift and go to state 21


state 3

    (3) stmt_list -> stmt .

    SEMICOLON       reduce using rule 3 (stmt_list -> stmt .)
    UNTIL           reduce using rule 3 (stmt_list -> stmt .)
    END             reduce using rule 3 (stmt_list -> stmt .)
    ELSE            reduce using rule 3 (stmt_list -> stmt .)


state 4

    (4) stmt -> assignment .

    SEMICOLON       reduce using rule 4 (stmt -> assignment .)
    UNTIL           reduce using rule 4 (stmt -> assignment .)
    END             reduce using rule 4 (stmt -> assignment .)
    ELSE            reduce using rule 4 (stmt -> assignment .)


state 5

    (5) stmt -> read .

    SEMICOLON       reduce using rule 5 (stmt -> read .)
    UNTIL           reduce using rule 5 (stmt -> read .)
    END             reduce using rule 5 (stmt -> read .)
    ELSE            reduce using rule 5 (stmt -> read .)


state 6

    (6) stmt -> write .

    SEMICOLON       reduce using rule 6 (stmt -> write .)
    UNTIL           reduce using rule 6 (stmt -> write .)
    END             reduce using rule 6 (stmt -> write .)
    ELSE            reduce using rule 6 (stmt -> write .)


state 7

    (7) stmt -> while .

    SEMICOLON       reduce using rule 7 (stmt -> while .)
    UNTIL           reduce using rule 7 (stmt -> while .)
    END             reduce using rule 7 (stmt -> while .)
    ELSE            reduce using rule 7 (stmt -> while .)


state 8

    (8) stmt -> repeat .

    SEMICOLON       reduce using rule 8 (stmt -> repeat .)
    UNTIL           reduce using rule 8 (stmt -> repeat .)
    END             reduce using rule 8 (stmt -> repeat .)
    ELSE            reduce using rule 8 (stmt -> repeat .)


state 9

    (9) stmt -> block .

    SEMICOLON       reduce using rule 9 (stmt -> block .)
    UNTIL           reduce using rule 9 (stmt -> block .)
    END             reduce using rule 9 (stmt -> block .)
    ELSE            reduce using rule 9 (stmt -> block .)


state 10

    (10) stmt -> foreach .

    SEMICOLON       reduce using rule 10 (stmt -> foreach .)
    UNTIL           reduce using rule 10 (stmt -> foreach .)
    END             reduce using rule 10 (stmt -> foreach .)
    ELSE            reduce using rule 10 (stmt -> foreach .)


state 11

    (11) stmt -> if_stmt .

    SEMICOLON       reduce using rule 11 (stmt -> if_stmt .)
    UNTIL           reduce using rule 11 (stmt -> if_stmt .)
    END             reduce using rule 11 (stmt -> if_stmt .)
    ELSE            reduce using rule 11 (stmt -> if_stmt .)


state 12

    (19) assignment -> varref . ASSIGN l_expr
    (32) varref -> varref . LBRACK a_expr RBRACK

    ASSIGN          shift and go to state 22
    LBRACK          shift and go to state 23


state 13

    (46) read -> READ . varlist
    (48) varlist -> . varref
    (49) varlist -> . varref COMMA_DELIM varlist
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    ID              shift and go to state 19

    varlist                        shift and go to state 24
    varref                         shift and go to state 25

state 14

    (47) write -> WRITE . expr_list
    (50) expr_list -> . a_expr
    (51) expr_list -> . expr_list COMMA_DELIM a_expr
    (20) a_expr -> . a_expr ADD a_term
    (21) a_expr -> . a_expr SUB a_term
    (22) a_expr -> . a_term
    (23) a_term -> . a_term MUL a_fact
    (24) a_term -> . a_term DIV a_fact
    (25) a_term -> . a_fact
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    expr_list                      shift and go to state 26
    a_expr                         shift and go to state 27
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 15

    (14) while -> WHILE . l_expr block
    (33) l_expr -> . l_expr AND l_term
    (34) l_expr -> . l_term
    (35) l_term -> . l_term OR l_fact
    (36) l_term -> . l_fact
    (37) l_fact -> . l_fact oprel a_expr
    (38) l_fact -> . a_expr
    (39) l_fact -> . LPAREN l_expr RPAREN
    (20) a_expr -> . a_expr ADD a_term
    (21) a_expr -> . a_expr SUB a_term
    (22) a_expr -> . a_term
    (23) a_term -> . a_term MUL a_fact
    (24) a_term -> . a_term DIV a_fact
    (25) a_term -> . a_fact
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 39
    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    ID              shift and go to state 19

    l_expr                         shift and go to state 35
    l_term                         shift and go to state 36
    l_fact                         shift and go to state 37
    a_expr                         shift and go to state 38
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 16

    (15) repeat -> REPEAT . stmt_list UNTIL l_expr
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (19) assignment -> . varref ASSIGN l_expr
    (46) read -> . READ varlist
    (47) write -> . WRITE expr_list
    (14) while -> . WHILE l_expr block
    (15) repeat -> . REPEAT stmt_list UNTIL l_expr
    (12) block -> . BEGIN stmt_list END
    (13) foreach -> . FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
    (16) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt_list                      shift and go to state 40
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 17

    (12) block -> BEGIN . stmt_list END
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (19) assignment -> . varref ASSIGN l_expr
    (46) read -> . READ varlist
    (47) write -> . WRITE expr_list
    (14) while -> . WHILE l_expr block
    (15) repeat -> . REPEAT stmt_list UNTIL l_expr
    (12) block -> . BEGIN stmt_list END
    (13) foreach -> . FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
    (16) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt_list                      shift and go to state 41
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 18

    (13) foreach -> FOREACH . ID IN LPAREN a_fact COLON a_fact RPAREN stmt

    ID              shift and go to state 42


state 19

    (31) varref -> ID .

    ASSIGN          reduce using rule 31 (varref -> ID .)
    LBRACK          reduce using rule 31 (varref -> ID .)
    COMMA_DELIM     reduce using rule 31 (varref -> ID .)
    SEMICOLON       reduce using rule 31 (varref -> ID .)
    UNTIL           reduce using rule 31 (varref -> ID .)
    END             reduce using rule 31 (varref -> ID .)
    ELSE            reduce using rule 31 (varref -> ID .)
    MUL             reduce using rule 31 (varref -> ID .)
    DIV             reduce using rule 31 (varref -> ID .)
    ADD             reduce using rule 31 (varref -> ID .)
    SUB             reduce using rule 31 (varref -> ID .)
    LT              reduce using rule 31 (varref -> ID .)
    GT              reduce using rule 31 (varref -> ID .)
    LEQ             reduce using rule 31 (varref -> ID .)
    GEQ             reduce using rule 31 (varref -> ID .)
    EQ              reduce using rule 31 (varref -> ID .)
    NEQ             reduce using rule 31 (varref -> ID .)
    OR              reduce using rule 31 (varref -> ID .)
    AND             reduce using rule 31 (varref -> ID .)
    BEGIN           reduce using rule 31 (varref -> ID .)
    THEN            reduce using rule 31 (varref -> ID .)
    RBRACK          reduce using rule 31 (varref -> ID .)
    RPAREN          reduce using rule 31 (varref -> ID .)
    COLON           reduce using rule 31 (varref -> ID .)


state 20

    (16) if_stmt -> IF . l_expr THEN stmt_list ELSE else_stmt
    (33) l_expr -> . l_expr AND l_term
    (34) l_expr -> . l_term
    (35) l_term -> . l_term OR l_fact
    (36) l_term -> . l_fact
    (37) l_fact -> . l_fact oprel a_expr
    (38) l_fact -> . a_expr
    (39) l_fact -> . LPAREN l_expr RPAREN
    (20) a_expr -> . a_expr ADD a_term
    (21) a_expr -> . a_expr SUB a_term
    (22) a_expr -> . a_term
    (23) a_term -> . a_term MUL a_fact
    (24) a_term -> . a_term DIV a_fact
    (25) a_term -> . a_fact
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 39
    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    ID              shift and go to state 19

    l_expr                         shift and go to state 43
    l_term                         shift and go to state 36
    l_fact                         shift and go to state 37
    a_expr                         shift and go to state 38
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 21

    (1) program -> stmt_list SEMICOLON .
    (2) stmt_list -> stmt_list SEMICOLON . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (19) assignment -> . varref ASSIGN l_expr
    (46) read -> . READ varlist
    (47) write -> . WRITE expr_list
    (14) while -> . WHILE l_expr block
    (15) repeat -> . REPEAT stmt_list UNTIL l_expr
    (12) block -> . BEGIN stmt_list END
    (13) foreach -> . FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
    (16) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    $end            reduce using rule 1 (program -> stmt_list SEMICOLON .)
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt                           shift and go to state 44
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 22

    (19) assignment -> varref ASSIGN . l_expr
    (33) l_expr -> . l_expr AND l_term
    (34) l_expr -> . l_term
    (35) l_term -> . l_term OR l_fact
    (36) l_term -> . l_fact
    (37) l_fact -> . l_fact oprel a_expr
    (38) l_fact -> . a_expr
    (39) l_fact -> . LPAREN l_expr RPAREN
    (20) a_expr -> . a_expr ADD a_term
    (21) a_expr -> . a_expr SUB a_term
    (22) a_expr -> . a_term
    (23) a_term -> . a_term MUL a_fact
    (24) a_term -> . a_term DIV a_fact
    (25) a_term -> . a_fact
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 39
    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    ID              shift and go to state 19

    varref                         shift and go to state 31
    l_expr                         shift and go to state 45
    l_term                         shift and go to state 36
    l_fact                         shift and go to state 37
    a_expr                         shift and go to state 38
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30

state 23

    (32) varref -> varref LBRACK . a_expr RBRACK
    (20) a_expr -> . a_expr ADD a_term
    (21) a_expr -> . a_expr SUB a_term
    (22) a_expr -> . a_term
    (23) a_term -> . a_term MUL a_fact
    (24) a_term -> . a_term DIV a_fact
    (25) a_term -> . a_fact
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    varref                         shift and go to state 31
    a_expr                         shift and go to state 46
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30

state 24

    (46) read -> READ varlist .

    SEMICOLON       reduce using rule 46 (read -> READ varlist .)
    UNTIL           reduce using rule 46 (read -> READ varlist .)
    END             reduce using rule 46 (read -> READ varlist .)
    ELSE            reduce using rule 46 (read -> READ varlist .)


state 25

    (48) varlist -> varref .
    (49) varlist -> varref . COMMA_DELIM varlist
    (32) varref -> varref . LBRACK a_expr RBRACK

    SEMICOLON       reduce using rule 48 (varlist -> varref .)
    UNTIL           reduce using rule 48 (varlist -> varref .)
    END             reduce using rule 48 (varlist -> varref .)
    ELSE            reduce using rule 48 (varlist -> varref .)
    COMMA_DELIM     shift and go to state 47
    LBRACK          shift and go to state 23


state 26

    (47) write -> WRITE expr_list .
    (51) expr_list -> expr_list . COMMA_DELIM a_expr

    SEMICOLON       reduce using rule 47 (write -> WRITE expr_list .)
    UNTIL           reduce using rule 47 (write -> WRITE expr_list .)
    END             reduce using rule 47 (write -> WRITE expr_list .)
    ELSE            reduce using rule 47 (write -> WRITE expr_list .)
    COMMA_DELIM     shift and go to state 48


state 27

    (50) expr_list -> a_expr .
    (20) a_expr -> a_expr . ADD a_term
    (21) a_expr -> a_expr . SUB a_term

    COMMA_DELIM     reduce using rule 50 (expr_list -> a_expr .)
    SEMICOLON       reduce using rule 50 (expr_list -> a_expr .)
    UNTIL           reduce using rule 50 (expr_list -> a_expr .)
    END             reduce using rule 50 (expr_list -> a_expr .)
    ELSE            reduce using rule 50 (expr_list -> a_expr .)
    ADD             shift and go to state 49
    SUB             shift and go to state 50


state 28

    (22) a_expr -> a_term .
    (23) a_term -> a_term . MUL a_fact
    (24) a_term -> a_term . DIV a_fact

    ADD             reduce using rule 22 (a_expr -> a_term .)
    SUB             reduce using rule 22 (a_expr -> a_term .)
    COMMA_DELIM     reduce using rule 22 (a_expr -> a_term .)
    SEMICOLON       reduce using rule 22 (a_expr -> a_term .)
    UNTIL           reduce using rule 22 (a_expr -> a_term .)
    END             reduce using rule 22 (a_expr -> a_term .)
    ELSE            reduce using rule 22 (a_expr -> a_term .)
    LT              reduce using rule 22 (a_expr -> a_term .)
    GT              reduce using rule 22 (a_expr -> a_term .)
    LEQ             reduce using rule 22 (a_expr -> a_term .)
    GEQ             reduce using rule 22 (a_expr -> a_term .)
    EQ              reduce using rule 22 (a_expr -> a_term .)
    NEQ             reduce using rule 22 (a_expr -> a_term .)
    OR              reduce using rule 22 (a_expr -> a_term .)
    AND             reduce using rule 22 (a_expr -> a_term .)
    BEGIN           reduce using rule 22 (a_expr -> a_term .)
    THEN            reduce using rule 22 (a_expr -> a_term .)
    RBRACK          reduce using rule 22 (a_expr -> a_term .)
    RPAREN          reduce using rule 22 (a_expr -> a_term .)
    MUL             shift and go to state 51
    DIV             shift and go to state 52


state 29

    (29) a_fact -> SUB . a_fact
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_fact                         shift and go to state 53
    varref                         shift and go to state 31

state 30

    (25) a_term -> a_fact .

    MUL             reduce using rule 25 (a_term -> a_fact .)
    DIV             reduce using rule 25 (a_term -> a_fact .)
    ADD             reduce using rule 25 (a_term -> a_fact .)
    SUB             reduce using rule 25 (a_term -> a_fact .)
    COMMA_DELIM     reduce using rule 25 (a_term -> a_fact .)
    SEMICOLON       reduce using rule 25 (a_term -> a_fact .)
    UNTIL           reduce using rule 25 (a_term -> a_fact .)
    END             reduce using rule 25 (a_term -> a_fact .)
    ELSE            reduce using rule 25 (a_term -> a_fact .)
    LT              reduce using rule 25 (a_term -> a_fact .)
    GT              reduce using rule 25 (a_term -> a_fact .)
    LEQ             reduce using rule 25 (a_term -> a_fact .)
    GEQ             reduce using rule 25 (a_term -> a_fact .)
    EQ              reduce using rule 25 (a_term -> a_fact .)
    NEQ             reduce using rule 25 (a_term -> a_fact .)
    OR              reduce using rule 25 (a_term -> a_fact .)
    AND             reduce using rule 25 (a_term -> a_fact .)
    BEGIN           reduce using rule 25 (a_term -> a_fact .)
    THEN            reduce using rule 25 (a_term -> a_fact .)
    RBRACK          reduce using rule 25 (a_term -> a_fact .)
    RPAREN          reduce using rule 25 (a_term -> a_fact .)


state 31

    (26) a_fact -> varref .
    (32) varref -> varref . LBRACK a_expr RBRACK

    MUL             reduce using rule 26 (a_fact -> varref .)
    DIV             reduce using rule 26 (a_fact -> varref .)
    ADD             reduce using rule 26 (a_fact -> varref .)
    SUB             reduce using rule 26 (a_fact -> varref .)
    COMMA_DELIM     reduce using rule 26 (a_fact -> varref .)
    SEMICOLON       reduce using rule 26 (a_fact -> varref .)
    UNTIL           reduce using rule 26 (a_fact -> varref .)
    END             reduce using rule 26 (a_fact -> varref .)
    ELSE            reduce using rule 26 (a_fact -> varref .)
    LT              reduce using rule 26 (a_fact -> varref .)
    GT              reduce using rule 26 (a_fact -> varref .)
    LEQ             reduce using rule 26 (a_fact -> varref .)
    GEQ             reduce using rule 26 (a_fact -> varref .)
    EQ              reduce using rule 26 (a_fact -> varref .)
    NEQ             reduce using rule 26 (a_fact -> varref .)
    OR              reduce using rule 26 (a_fact -> varref .)
    AND             reduce using rule 26 (a_fact -> varref .)
    BEGIN           reduce using rule 26 (a_fact -> varref .)
    THEN            reduce using rule 26 (a_fact -> varref .)
    RBRACK          reduce using rule 26 (a_fact -> varref .)
    RPAREN          reduce using rule 26 (a_fact -> varref .)
    COLON           reduce using rule 26 (a_fact -> varref .)
    LBRACK          shift and go to state 23


state 32

    (27) a_fact -> NUM .

    MUL             reduce using rule 27 (a_fact -> NUM .)
    DIV             reduce using rule 27 (a_fact -> NUM .)
    ADD             reduce using rule 27 (a_fact -> NUM .)
    SUB             reduce using rule 27 (a_fact -> NUM .)
    COMMA_DELIM     reduce using rule 27 (a_fact -> NUM .)
    SEMICOLON       reduce using rule 27 (a_fact -> NUM .)
    UNTIL           reduce using rule 27 (a_fact -> NUM .)
    END             reduce using rule 27 (a_fact -> NUM .)
    ELSE            reduce using rule 27 (a_fact -> NUM .)
    LT              reduce using rule 27 (a_fact -> NUM .)
    GT              reduce using rule 27 (a_fact -> NUM .)
    LEQ             reduce using rule 27 (a_fact -> NUM .)
    GEQ             reduce using rule 27 (a_fact -> NUM .)
    EQ              reduce using rule 27 (a_fact -> NUM .)
    NEQ             reduce using rule 27 (a_fact -> NUM .)
    OR              reduce using rule 27 (a_fact -> NUM .)
    AND             reduce using rule 27 (a_fact -> NUM .)
    BEGIN           reduce using rule 27 (a_fact -> NUM .)
    THEN            reduce using rule 27 (a_fact -> NUM .)
    RBRACK          reduce using rule 27 (a_fact -> NUM .)
    RPAREN          reduce using rule 27 (a_fact -> NUM .)
    COLON           reduce using rule 27 (a_fact -> NUM .)


state 33

    (28) a_fact -> LITERAL_STR .

    MUL             reduce using rule 28 (a_fact -> LITERAL_STR .)
    DIV             reduce using rule 28 (a_fact -> LITERAL_STR .)
    ADD             reduce using rule 28 (a_fact -> LITERAL_STR .)
    SUB             reduce using rule 28 (a_fact -> LITERAL_STR .)
    COMMA_DELIM     reduce using rule 28 (a_fact -> LITERAL_STR .)
    SEMICOLON       reduce using rule 28 (a_fact -> LITERAL_STR .)
    UNTIL           reduce using rule 28 (a_fact -> LITERAL_STR .)
    END             reduce using rule 28 (a_fact -> LITERAL_STR .)
    ELSE            reduce using rule 28 (a_fact -> LITERAL_STR .)
    LT              reduce using rule 28 (a_fact -> LITERAL_STR .)
    GT              reduce using rule 28 (a_fact -> LITERAL_STR .)
    LEQ             reduce using rule 28 (a_fact -> LITERAL_STR .)
    GEQ             reduce using rule 28 (a_fact -> LITERAL_STR .)
    EQ              reduce using rule 28 (a_fact -> LITERAL_STR .)
    NEQ             reduce using rule 28 (a_fact -> LITERAL_STR .)
    OR              reduce using rule 28 (a_fact -> LITERAL_STR .)
    AND             reduce using rule 28 (a_fact -> LITERAL_STR .)
    BEGIN           reduce using rule 28 (a_fact -> LITERAL_STR .)
    THEN            reduce using rule 28 (a_fact -> LITERAL_STR .)
    RBRACK          reduce using rule 28 (a_fact -> LITERAL_STR .)
    RPAREN          reduce using rule 28 (a_fact -> LITERAL_STR .)
    COLON           reduce using rule 28 (a_fact -> LITERAL_STR .)


state 34

    (30) a_fact -> LPAREN . a_expr RPAREN
    (20) a_expr -> . a_expr ADD a_term
    (21) a_expr -> . a_expr SUB a_term
    (22) a_expr -> . a_term
    (23) a_term -> . a_term MUL a_fact
    (24) a_term -> . a_term DIV a_fact
    (25) a_term -> . a_fact
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_expr                         shift and go to state 54
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 35

    (14) while -> WHILE l_expr . block
    (33) l_expr -> l_expr . AND l_term
    (12) block -> . BEGIN stmt_list END

    AND             shift and go to state 56
    BEGIN           shift and go to state 17

    block                          shift and go to state 55

state 36

    (34) l_expr -> l_term .
    (35) l_term -> l_term . OR l_fact

    AND             reduce using rule 34 (l_expr -> l_term .)
    BEGIN           reduce using rule 34 (l_expr -> l_term .)
    THEN            reduce using rule 34 (l_expr -> l_term .)
    SEMICOLON       reduce using rule 34 (l_expr -> l_term .)
    UNTIL           reduce using rule 34 (l_expr -> l_term .)
    END             reduce using rule 34 (l_expr -> l_term .)
    ELSE            reduce using rule 34 (l_expr -> l_term .)
    RPAREN          reduce using rule 34 (l_expr -> l_term .)
    OR              shift and go to state 57


state 37

    (36) l_term -> l_fact .
    (37) l_fact -> l_fact . oprel a_expr
    (40) oprel -> . LT
    (41) oprel -> . GT
    (42) oprel -> . LEQ
    (43) oprel -> . GEQ
    (44) oprel -> . EQ
    (45) oprel -> . NEQ

    OR              reduce using rule 36 (l_term -> l_fact .)
    AND             reduce using rule 36 (l_term -> l_fact .)
    BEGIN           reduce using rule 36 (l_term -> l_fact .)
    THEN            reduce using rule 36 (l_term -> l_fact .)
    SEMICOLON       reduce using rule 36 (l_term -> l_fact .)
    UNTIL           reduce using rule 36 (l_term -> l_fact .)
    END             reduce using rule 36 (l_term -> l_fact .)
    ELSE            reduce using rule 36 (l_term -> l_fact .)
    RPAREN          reduce using rule 36 (l_term -> l_fact .)
    LT              shift and go to state 59
    GT              shift and go to state 60
    LEQ             shift and go to state 61
    GEQ             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64

    oprel                          shift and go to state 58

state 38

    (38) l_fact -> a_expr .
    (20) a_expr -> a_expr . ADD a_term
    (21) a_expr -> a_expr . SUB a_term

    LT              reduce using rule 38 (l_fact -> a_expr .)
    GT              reduce using rule 38 (l_fact -> a_expr .)
    LEQ             reduce using rule 38 (l_fact -> a_expr .)
    GEQ             reduce using rule 38 (l_fact -> a_expr .)
    EQ              reduce using rule 38 (l_fact -> a_expr .)
    NEQ             reduce using rule 38 (l_fact -> a_expr .)
    OR              reduce using rule 38 (l_fact -> a_expr .)
    AND             reduce using rule 38 (l_fact -> a_expr .)
    BEGIN           reduce using rule 38 (l_fact -> a_expr .)
    THEN            reduce using rule 38 (l_fact -> a_expr .)
    SEMICOLON       reduce using rule 38 (l_fact -> a_expr .)
    UNTIL           reduce using rule 38 (l_fact -> a_expr .)
    END             reduce using rule 38 (l_fact -> a_expr .)
    ELSE            reduce using rule 38 (l_fact -> a_expr .)
    RPAREN          reduce using rule 38 (l_fact -> a_expr .)
    ADD             shift and go to state 49
    SUB             shift and go to state 50


state 39

    (39) l_fact -> LPAREN . l_expr RPAREN
    (30) a_fact -> LPAREN . a_expr RPAREN
    (33) l_expr -> . l_expr AND l_term
    (34) l_expr -> . l_term
    (20) a_expr -> . a_expr ADD a_term
    (21) a_expr -> . a_expr SUB a_term
    (22) a_expr -> . a_term
    (35) l_term -> . l_term OR l_fact
    (36) l_term -> . l_fact
    (23) a_term -> . a_term MUL a_fact
    (24) a_term -> . a_term DIV a_fact
    (25) a_term -> . a_fact
    (37) l_fact -> . l_fact oprel a_expr
    (38) l_fact -> . a_expr
    (39) l_fact -> . LPAREN l_expr RPAREN
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 39
    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    ID              shift and go to state 19

    l_expr                         shift and go to state 65
    a_expr                         shift and go to state 66
    l_term                         shift and go to state 36
    a_term                         shift and go to state 28
    l_fact                         shift and go to state 37
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 40

    (15) repeat -> REPEAT stmt_list . UNTIL l_expr
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    UNTIL           shift and go to state 67
    SEMICOLON       shift and go to state 68


state 41

    (12) block -> BEGIN stmt_list . END
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    END             shift and go to state 69
    SEMICOLON       shift and go to state 68


state 42

    (13) foreach -> FOREACH ID . IN LPAREN a_fact COLON a_fact RPAREN stmt

    IN              shift and go to state 70


state 43

    (16) if_stmt -> IF l_expr . THEN stmt_list ELSE else_stmt
    (33) l_expr -> l_expr . AND l_term

    THEN            shift and go to state 71
    AND             shift and go to state 56


state 44

    (2) stmt_list -> stmt_list SEMICOLON stmt .

    SEMICOLON       reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)
    UNTIL           reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)
    END             reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)
    ELSE            reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)


state 45

    (19) assignment -> varref ASSIGN l_expr .
    (33) l_expr -> l_expr . AND l_term

    SEMICOLON       reduce using rule 19 (assignment -> varref ASSIGN l_expr .)
    UNTIL           reduce using rule 19 (assignment -> varref ASSIGN l_expr .)
    END             reduce using rule 19 (assignment -> varref ASSIGN l_expr .)
    ELSE            reduce using rule 19 (assignment -> varref ASSIGN l_expr .)
    AND             shift and go to state 56


state 46

    (32) varref -> varref LBRACK a_expr . RBRACK
    (20) a_expr -> a_expr . ADD a_term
    (21) a_expr -> a_expr . SUB a_term

    RBRACK          shift and go to state 72
    ADD             shift and go to state 49
    SUB             shift and go to state 50


state 47

    (49) varlist -> varref COMMA_DELIM . varlist
    (48) varlist -> . varref
    (49) varlist -> . varref COMMA_DELIM varlist
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    ID              shift and go to state 19

    varref                         shift and go to state 25
    varlist                        shift and go to state 73

state 48

    (51) expr_list -> expr_list COMMA_DELIM . a_expr
    (20) a_expr -> . a_expr ADD a_term
    (21) a_expr -> . a_expr SUB a_term
    (22) a_expr -> . a_term
    (23) a_term -> . a_term MUL a_fact
    (24) a_term -> . a_term DIV a_fact
    (25) a_term -> . a_fact
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_expr                         shift and go to state 74
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 49

    (20) a_expr -> a_expr ADD . a_term
    (23) a_term -> . a_term MUL a_fact
    (24) a_term -> . a_term DIV a_fact
    (25) a_term -> . a_fact
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_term                         shift and go to state 75
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 50

    (21) a_expr -> a_expr SUB . a_term
    (23) a_term -> . a_term MUL a_fact
    (24) a_term -> . a_term DIV a_fact
    (25) a_term -> . a_fact
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_term                         shift and go to state 76
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 51

    (23) a_term -> a_term MUL . a_fact
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_fact                         shift and go to state 77
    varref                         shift and go to state 31

state 52

    (24) a_term -> a_term DIV . a_fact
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_fact                         shift and go to state 78
    varref                         shift and go to state 31

state 53

    (29) a_fact -> SUB a_fact .

    MUL             reduce using rule 29 (a_fact -> SUB a_fact .)
    DIV             reduce using rule 29 (a_fact -> SUB a_fact .)
    ADD             reduce using rule 29 (a_fact -> SUB a_fact .)
    SUB             reduce using rule 29 (a_fact -> SUB a_fact .)
    COMMA_DELIM     reduce using rule 29 (a_fact -> SUB a_fact .)
    SEMICOLON       reduce using rule 29 (a_fact -> SUB a_fact .)
    UNTIL           reduce using rule 29 (a_fact -> SUB a_fact .)
    END             reduce using rule 29 (a_fact -> SUB a_fact .)
    ELSE            reduce using rule 29 (a_fact -> SUB a_fact .)
    LT              reduce using rule 29 (a_fact -> SUB a_fact .)
    GT              reduce using rule 29 (a_fact -> SUB a_fact .)
    LEQ             reduce using rule 29 (a_fact -> SUB a_fact .)
    GEQ             reduce using rule 29 (a_fact -> SUB a_fact .)
    EQ              reduce using rule 29 (a_fact -> SUB a_fact .)
    NEQ             reduce using rule 29 (a_fact -> SUB a_fact .)
    OR              reduce using rule 29 (a_fact -> SUB a_fact .)
    AND             reduce using rule 29 (a_fact -> SUB a_fact .)
    BEGIN           reduce using rule 29 (a_fact -> SUB a_fact .)
    THEN            reduce using rule 29 (a_fact -> SUB a_fact .)
    RBRACK          reduce using rule 29 (a_fact -> SUB a_fact .)
    RPAREN          reduce using rule 29 (a_fact -> SUB a_fact .)
    COLON           reduce using rule 29 (a_fact -> SUB a_fact .)


state 54

    (30) a_fact -> LPAREN a_expr . RPAREN
    (20) a_expr -> a_expr . ADD a_term
    (21) a_expr -> a_expr . SUB a_term

    RPAREN          shift and go to state 79
    ADD             shift and go to state 49
    SUB             shift and go to state 50


state 55

    (14) while -> WHILE l_expr block .

    SEMICOLON       reduce using rule 14 (while -> WHILE l_expr block .)
    UNTIL           reduce using rule 14 (while -> WHILE l_expr block .)
    END             reduce using rule 14 (while -> WHILE l_expr block .)
    ELSE            reduce using rule 14 (while -> WHILE l_expr block .)


state 56

    (33) l_expr -> l_expr AND . l_term
    (35) l_term -> . l_term OR l_fact
    (36) l_term -> . l_fact
    (37) l_fact -> . l_fact oprel a_expr
    (38) l_fact -> . a_expr
    (39) l_fact -> . LPAREN l_expr RPAREN
    (20) a_expr -> . a_expr ADD a_term
    (21) a_expr -> . a_expr SUB a_term
    (22) a_expr -> . a_term
    (23) a_term -> . a_term MUL a_fact
    (24) a_term -> . a_term DIV a_fact
    (25) a_term -> . a_fact
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 39
    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    ID              shift and go to state 19

    l_term                         shift and go to state 80
    l_fact                         shift and go to state 37
    a_expr                         shift and go to state 38
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 57

    (35) l_term -> l_term OR . l_fact
    (37) l_fact -> . l_fact oprel a_expr
    (38) l_fact -> . a_expr
    (39) l_fact -> . LPAREN l_expr RPAREN
    (20) a_expr -> . a_expr ADD a_term
    (21) a_expr -> . a_expr SUB a_term
    (22) a_expr -> . a_term
    (23) a_term -> . a_term MUL a_fact
    (24) a_term -> . a_term DIV a_fact
    (25) a_term -> . a_fact
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 39
    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    ID              shift and go to state 19

    l_fact                         shift and go to state 81
    a_expr                         shift and go to state 38
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 58

    (37) l_fact -> l_fact oprel . a_expr
    (20) a_expr -> . a_expr ADD a_term
    (21) a_expr -> . a_expr SUB a_term
    (22) a_expr -> . a_term
    (23) a_term -> . a_term MUL a_fact
    (24) a_term -> . a_term DIV a_fact
    (25) a_term -> . a_fact
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_expr                         shift and go to state 82
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 59

    (40) oprel -> LT .

    NUM             reduce using rule 40 (oprel -> LT .)
    LITERAL_STR     reduce using rule 40 (oprel -> LT .)
    SUB             reduce using rule 40 (oprel -> LT .)
    LPAREN          reduce using rule 40 (oprel -> LT .)
    ID              reduce using rule 40 (oprel -> LT .)


state 60

    (41) oprel -> GT .

    NUM             reduce using rule 41 (oprel -> GT .)
    LITERAL_STR     reduce using rule 41 (oprel -> GT .)
    SUB             reduce using rule 41 (oprel -> GT .)
    LPAREN          reduce using rule 41 (oprel -> GT .)
    ID              reduce using rule 41 (oprel -> GT .)


state 61

    (42) oprel -> LEQ .

    NUM             reduce using rule 42 (oprel -> LEQ .)
    LITERAL_STR     reduce using rule 42 (oprel -> LEQ .)
    SUB             reduce using rule 42 (oprel -> LEQ .)
    LPAREN          reduce using rule 42 (oprel -> LEQ .)
    ID              reduce using rule 42 (oprel -> LEQ .)


state 62

    (43) oprel -> GEQ .

    NUM             reduce using rule 43 (oprel -> GEQ .)
    LITERAL_STR     reduce using rule 43 (oprel -> GEQ .)
    SUB             reduce using rule 43 (oprel -> GEQ .)
    LPAREN          reduce using rule 43 (oprel -> GEQ .)
    ID              reduce using rule 43 (oprel -> GEQ .)


state 63

    (44) oprel -> EQ .

    NUM             reduce using rule 44 (oprel -> EQ .)
    LITERAL_STR     reduce using rule 44 (oprel -> EQ .)
    SUB             reduce using rule 44 (oprel -> EQ .)
    LPAREN          reduce using rule 44 (oprel -> EQ .)
    ID              reduce using rule 44 (oprel -> EQ .)


state 64

    (45) oprel -> NEQ .

    NUM             reduce using rule 45 (oprel -> NEQ .)
    LITERAL_STR     reduce using rule 45 (oprel -> NEQ .)
    SUB             reduce using rule 45 (oprel -> NEQ .)
    LPAREN          reduce using rule 45 (oprel -> NEQ .)
    ID              reduce using rule 45 (oprel -> NEQ .)


state 65

    (39) l_fact -> LPAREN l_expr . RPAREN
    (33) l_expr -> l_expr . AND l_term

    RPAREN          shift and go to state 83
    AND             shift and go to state 56


state 66

    (30) a_fact -> LPAREN a_expr . RPAREN
    (20) a_expr -> a_expr . ADD a_term
    (21) a_expr -> a_expr . SUB a_term
    (38) l_fact -> a_expr .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 79
    ADD             shift and go to state 49
    SUB             shift and go to state 50
    LT              reduce using rule 38 (l_fact -> a_expr .)
    GT              reduce using rule 38 (l_fact -> a_expr .)
    LEQ             reduce using rule 38 (l_fact -> a_expr .)
    GEQ             reduce using rule 38 (l_fact -> a_expr .)
    EQ              reduce using rule 38 (l_fact -> a_expr .)
    NEQ             reduce using rule 38 (l_fact -> a_expr .)
    OR              reduce using rule 38 (l_fact -> a_expr .)
    AND             reduce using rule 38 (l_fact -> a_expr .)

  ! RPAREN          [ reduce using rule 38 (l_fact -> a_expr .) ]


state 67

    (15) repeat -> REPEAT stmt_list UNTIL . l_expr
    (33) l_expr -> . l_expr AND l_term
    (34) l_expr -> . l_term
    (35) l_term -> . l_term OR l_fact
    (36) l_term -> . l_fact
    (37) l_fact -> . l_fact oprel a_expr
    (38) l_fact -> . a_expr
    (39) l_fact -> . LPAREN l_expr RPAREN
    (20) a_expr -> . a_expr ADD a_term
    (21) a_expr -> . a_expr SUB a_term
    (22) a_expr -> . a_term
    (23) a_term -> . a_term MUL a_fact
    (24) a_term -> . a_term DIV a_fact
    (25) a_term -> . a_fact
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    LPAREN          shift and go to state 39
    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    ID              shift and go to state 19

    l_expr                         shift and go to state 84
    l_term                         shift and go to state 36
    l_fact                         shift and go to state 37
    a_expr                         shift and go to state 38
    a_term                         shift and go to state 28
    a_fact                         shift and go to state 30
    varref                         shift and go to state 31

state 68

    (2) stmt_list -> stmt_list SEMICOLON . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (19) assignment -> . varref ASSIGN l_expr
    (46) read -> . READ varlist
    (47) write -> . WRITE expr_list
    (14) while -> . WHILE l_expr block
    (15) repeat -> . REPEAT stmt_list UNTIL l_expr
    (12) block -> . BEGIN stmt_list END
    (13) foreach -> . FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
    (16) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt                           shift and go to state 44
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 69

    (12) block -> BEGIN stmt_list END .

    SEMICOLON       reduce using rule 12 (block -> BEGIN stmt_list END .)
    UNTIL           reduce using rule 12 (block -> BEGIN stmt_list END .)
    END             reduce using rule 12 (block -> BEGIN stmt_list END .)
    ELSE            reduce using rule 12 (block -> BEGIN stmt_list END .)


state 70

    (13) foreach -> FOREACH ID IN . LPAREN a_fact COLON a_fact RPAREN stmt

    LPAREN          shift and go to state 85


state 71

    (16) if_stmt -> IF l_expr THEN . stmt_list ELSE else_stmt
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (19) assignment -> . varref ASSIGN l_expr
    (46) read -> . READ varlist
    (47) write -> . WRITE expr_list
    (14) while -> . WHILE l_expr block
    (15) repeat -> . REPEAT stmt_list UNTIL l_expr
    (12) block -> . BEGIN stmt_list END
    (13) foreach -> . FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
    (16) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt_list                      shift and go to state 86
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 72

    (32) varref -> varref LBRACK a_expr RBRACK .

    ASSIGN          reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    LBRACK          reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    COMMA_DELIM     reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    SEMICOLON       reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    UNTIL           reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    END             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    ELSE            reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    MUL             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    DIV             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    ADD             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    SUB             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    LT              reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    GT              reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    LEQ             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    GEQ             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    EQ              reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    NEQ             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    OR              reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    AND             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    BEGIN           reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    THEN            reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    RBRACK          reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    RPAREN          reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    COLON           reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)


state 73

    (49) varlist -> varref COMMA_DELIM varlist .

    SEMICOLON       reduce using rule 49 (varlist -> varref COMMA_DELIM varlist .)
    UNTIL           reduce using rule 49 (varlist -> varref COMMA_DELIM varlist .)
    END             reduce using rule 49 (varlist -> varref COMMA_DELIM varlist .)
    ELSE            reduce using rule 49 (varlist -> varref COMMA_DELIM varlist .)


state 74

    (51) expr_list -> expr_list COMMA_DELIM a_expr .
    (20) a_expr -> a_expr . ADD a_term
    (21) a_expr -> a_expr . SUB a_term

    COMMA_DELIM     reduce using rule 51 (expr_list -> expr_list COMMA_DELIM a_expr .)
    SEMICOLON       reduce using rule 51 (expr_list -> expr_list COMMA_DELIM a_expr .)
    UNTIL           reduce using rule 51 (expr_list -> expr_list COMMA_DELIM a_expr .)
    END             reduce using rule 51 (expr_list -> expr_list COMMA_DELIM a_expr .)
    ELSE            reduce using rule 51 (expr_list -> expr_list COMMA_DELIM a_expr .)
    ADD             shift and go to state 49
    SUB             shift and go to state 50


state 75

    (20) a_expr -> a_expr ADD a_term .
    (23) a_term -> a_term . MUL a_fact
    (24) a_term -> a_term . DIV a_fact

    ADD             reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    SUB             reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    COMMA_DELIM     reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    SEMICOLON       reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    UNTIL           reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    END             reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    ELSE            reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    LT              reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    GT              reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    LEQ             reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    GEQ             reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    EQ              reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    NEQ             reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    OR              reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    AND             reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    BEGIN           reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    THEN            reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    RBRACK          reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    RPAREN          reduce using rule 20 (a_expr -> a_expr ADD a_term .)
    MUL             shift and go to state 51
    DIV             shift and go to state 52


state 76

    (21) a_expr -> a_expr SUB a_term .
    (23) a_term -> a_term . MUL a_fact
    (24) a_term -> a_term . DIV a_fact

    ADD             reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    SUB             reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    COMMA_DELIM     reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    SEMICOLON       reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    UNTIL           reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    END             reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    ELSE            reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    LT              reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    GT              reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    LEQ             reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    GEQ             reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    EQ              reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    NEQ             reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    OR              reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    AND             reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    BEGIN           reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    THEN            reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    RBRACK          reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    RPAREN          reduce using rule 21 (a_expr -> a_expr SUB a_term .)
    MUL             shift and go to state 51
    DIV             shift and go to state 52


state 77

    (23) a_term -> a_term MUL a_fact .

    MUL             reduce using rule 23 (a_term -> a_term MUL a_fact .)
    DIV             reduce using rule 23 (a_term -> a_term MUL a_fact .)
    ADD             reduce using rule 23 (a_term -> a_term MUL a_fact .)
    SUB             reduce using rule 23 (a_term -> a_term MUL a_fact .)
    COMMA_DELIM     reduce using rule 23 (a_term -> a_term MUL a_fact .)
    SEMICOLON       reduce using rule 23 (a_term -> a_term MUL a_fact .)
    UNTIL           reduce using rule 23 (a_term -> a_term MUL a_fact .)
    END             reduce using rule 23 (a_term -> a_term MUL a_fact .)
    ELSE            reduce using rule 23 (a_term -> a_term MUL a_fact .)
    LT              reduce using rule 23 (a_term -> a_term MUL a_fact .)
    GT              reduce using rule 23 (a_term -> a_term MUL a_fact .)
    LEQ             reduce using rule 23 (a_term -> a_term MUL a_fact .)
    GEQ             reduce using rule 23 (a_term -> a_term MUL a_fact .)
    EQ              reduce using rule 23 (a_term -> a_term MUL a_fact .)
    NEQ             reduce using rule 23 (a_term -> a_term MUL a_fact .)
    OR              reduce using rule 23 (a_term -> a_term MUL a_fact .)
    AND             reduce using rule 23 (a_term -> a_term MUL a_fact .)
    BEGIN           reduce using rule 23 (a_term -> a_term MUL a_fact .)
    THEN            reduce using rule 23 (a_term -> a_term MUL a_fact .)
    RBRACK          reduce using rule 23 (a_term -> a_term MUL a_fact .)
    RPAREN          reduce using rule 23 (a_term -> a_term MUL a_fact .)


state 78

    (24) a_term -> a_term DIV a_fact .

    MUL             reduce using rule 24 (a_term -> a_term DIV a_fact .)
    DIV             reduce using rule 24 (a_term -> a_term DIV a_fact .)
    ADD             reduce using rule 24 (a_term -> a_term DIV a_fact .)
    SUB             reduce using rule 24 (a_term -> a_term DIV a_fact .)
    COMMA_DELIM     reduce using rule 24 (a_term -> a_term DIV a_fact .)
    SEMICOLON       reduce using rule 24 (a_term -> a_term DIV a_fact .)
    UNTIL           reduce using rule 24 (a_term -> a_term DIV a_fact .)
    END             reduce using rule 24 (a_term -> a_term DIV a_fact .)
    ELSE            reduce using rule 24 (a_term -> a_term DIV a_fact .)
    LT              reduce using rule 24 (a_term -> a_term DIV a_fact .)
    GT              reduce using rule 24 (a_term -> a_term DIV a_fact .)
    LEQ             reduce using rule 24 (a_term -> a_term DIV a_fact .)
    GEQ             reduce using rule 24 (a_term -> a_term DIV a_fact .)
    EQ              reduce using rule 24 (a_term -> a_term DIV a_fact .)
    NEQ             reduce using rule 24 (a_term -> a_term DIV a_fact .)
    OR              reduce using rule 24 (a_term -> a_term DIV a_fact .)
    AND             reduce using rule 24 (a_term -> a_term DIV a_fact .)
    BEGIN           reduce using rule 24 (a_term -> a_term DIV a_fact .)
    THEN            reduce using rule 24 (a_term -> a_term DIV a_fact .)
    RBRACK          reduce using rule 24 (a_term -> a_term DIV a_fact .)
    RPAREN          reduce using rule 24 (a_term -> a_term DIV a_fact .)


state 79

    (30) a_fact -> LPAREN a_expr RPAREN .

    MUL             reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    DIV             reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    ADD             reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    SUB             reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    COMMA_DELIM     reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    SEMICOLON       reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    UNTIL           reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    END             reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    ELSE            reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    LT              reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    GT              reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    LEQ             reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    GEQ             reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    EQ              reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    NEQ             reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    OR              reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    AND             reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    BEGIN           reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    THEN            reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    RBRACK          reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    RPAREN          reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)
    COLON           reduce using rule 30 (a_fact -> LPAREN a_expr RPAREN .)


state 80

    (33) l_expr -> l_expr AND l_term .
    (35) l_term -> l_term . OR l_fact

    AND             reduce using rule 33 (l_expr -> l_expr AND l_term .)
    BEGIN           reduce using rule 33 (l_expr -> l_expr AND l_term .)
    THEN            reduce using rule 33 (l_expr -> l_expr AND l_term .)
    SEMICOLON       reduce using rule 33 (l_expr -> l_expr AND l_term .)
    UNTIL           reduce using rule 33 (l_expr -> l_expr AND l_term .)
    END             reduce using rule 33 (l_expr -> l_expr AND l_term .)
    ELSE            reduce using rule 33 (l_expr -> l_expr AND l_term .)
    RPAREN          reduce using rule 33 (l_expr -> l_expr AND l_term .)
    OR              shift and go to state 57


state 81

    (35) l_term -> l_term OR l_fact .
    (37) l_fact -> l_fact . oprel a_expr
    (40) oprel -> . LT
    (41) oprel -> . GT
    (42) oprel -> . LEQ
    (43) oprel -> . GEQ
    (44) oprel -> . EQ
    (45) oprel -> . NEQ

    OR              reduce using rule 35 (l_term -> l_term OR l_fact .)
    AND             reduce using rule 35 (l_term -> l_term OR l_fact .)
    BEGIN           reduce using rule 35 (l_term -> l_term OR l_fact .)
    THEN            reduce using rule 35 (l_term -> l_term OR l_fact .)
    SEMICOLON       reduce using rule 35 (l_term -> l_term OR l_fact .)
    UNTIL           reduce using rule 35 (l_term -> l_term OR l_fact .)
    END             reduce using rule 35 (l_term -> l_term OR l_fact .)
    ELSE            reduce using rule 35 (l_term -> l_term OR l_fact .)
    RPAREN          reduce using rule 35 (l_term -> l_term OR l_fact .)
    LT              shift and go to state 59
    GT              shift and go to state 60
    LEQ             shift and go to state 61
    GEQ             shift and go to state 62
    EQ              shift and go to state 63
    NEQ             shift and go to state 64

    oprel                          shift and go to state 58

state 82

    (37) l_fact -> l_fact oprel a_expr .
    (20) a_expr -> a_expr . ADD a_term
    (21) a_expr -> a_expr . SUB a_term

    LT              reduce using rule 37 (l_fact -> l_fact oprel a_expr .)
    GT              reduce using rule 37 (l_fact -> l_fact oprel a_expr .)
    LEQ             reduce using rule 37 (l_fact -> l_fact oprel a_expr .)
    GEQ             reduce using rule 37 (l_fact -> l_fact oprel a_expr .)
    EQ              reduce using rule 37 (l_fact -> l_fact oprel a_expr .)
    NEQ             reduce using rule 37 (l_fact -> l_fact oprel a_expr .)
    OR              reduce using rule 37 (l_fact -> l_fact oprel a_expr .)
    AND             reduce using rule 37 (l_fact -> l_fact oprel a_expr .)
    BEGIN           reduce using rule 37 (l_fact -> l_fact oprel a_expr .)
    THEN            reduce using rule 37 (l_fact -> l_fact oprel a_expr .)
    SEMICOLON       reduce using rule 37 (l_fact -> l_fact oprel a_expr .)
    UNTIL           reduce using rule 37 (l_fact -> l_fact oprel a_expr .)
    END             reduce using rule 37 (l_fact -> l_fact oprel a_expr .)
    ELSE            reduce using rule 37 (l_fact -> l_fact oprel a_expr .)
    RPAREN          reduce using rule 37 (l_fact -> l_fact oprel a_expr .)
    ADD             shift and go to state 49
    SUB             shift and go to state 50


state 83

    (39) l_fact -> LPAREN l_expr RPAREN .

    LT              reduce using rule 39 (l_fact -> LPAREN l_expr RPAREN .)
    GT              reduce using rule 39 (l_fact -> LPAREN l_expr RPAREN .)
    LEQ             reduce using rule 39 (l_fact -> LPAREN l_expr RPAREN .)
    GEQ             reduce using rule 39 (l_fact -> LPAREN l_expr RPAREN .)
    EQ              reduce using rule 39 (l_fact -> LPAREN l_expr RPAREN .)
    NEQ             reduce using rule 39 (l_fact -> LPAREN l_expr RPAREN .)
    OR              reduce using rule 39 (l_fact -> LPAREN l_expr RPAREN .)
    AND             reduce using rule 39 (l_fact -> LPAREN l_expr RPAREN .)
    BEGIN           reduce using rule 39 (l_fact -> LPAREN l_expr RPAREN .)
    THEN            reduce using rule 39 (l_fact -> LPAREN l_expr RPAREN .)
    SEMICOLON       reduce using rule 39 (l_fact -> LPAREN l_expr RPAREN .)
    UNTIL           reduce using rule 39 (l_fact -> LPAREN l_expr RPAREN .)
    END             reduce using rule 39 (l_fact -> LPAREN l_expr RPAREN .)
    ELSE            reduce using rule 39 (l_fact -> LPAREN l_expr RPAREN .)
    RPAREN          reduce using rule 39 (l_fact -> LPAREN l_expr RPAREN .)


state 84

    (15) repeat -> REPEAT stmt_list UNTIL l_expr .
    (33) l_expr -> l_expr . AND l_term

    SEMICOLON       reduce using rule 15 (repeat -> REPEAT stmt_list UNTIL l_expr .)
    UNTIL           reduce using rule 15 (repeat -> REPEAT stmt_list UNTIL l_expr .)
    END             reduce using rule 15 (repeat -> REPEAT stmt_list UNTIL l_expr .)
    ELSE            reduce using rule 15 (repeat -> REPEAT stmt_list UNTIL l_expr .)
    AND             shift and go to state 56


state 85

    (13) foreach -> FOREACH ID IN LPAREN . a_fact COLON a_fact RPAREN stmt
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_fact                         shift and go to state 87
    varref                         shift and go to state 31

state 86

    (16) if_stmt -> IF l_expr THEN stmt_list . ELSE else_stmt
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    ELSE            shift and go to state 88
    SEMICOLON       shift and go to state 68


state 87

    (13) foreach -> FOREACH ID IN LPAREN a_fact . COLON a_fact RPAREN stmt

    COLON           shift and go to state 89


state 88

    (16) if_stmt -> IF l_expr THEN stmt_list ELSE . else_stmt
    (17) else_stmt -> .
    (18) else_stmt -> . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 17 (else_stmt -> .)
    UNTIL           reduce using rule 17 (else_stmt -> .)
    END             reduce using rule 17 (else_stmt -> .)
    ELSE            shift and go to state 90

  ! ELSE            [ reduce using rule 17 (else_stmt -> .) ]

    else_stmt                      shift and go to state 91

state 89

    (13) foreach -> FOREACH ID IN LPAREN a_fact COLON . a_fact RPAREN stmt
    (26) a_fact -> . varref
    (27) a_fact -> . NUM
    (28) a_fact -> . LITERAL_STR
    (29) a_fact -> . SUB a_fact
    (30) a_fact -> . LPAREN a_expr RPAREN
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    NUM             shift and go to state 32
    LITERAL_STR     shift and go to state 33
    SUB             shift and go to state 29
    LPAREN          shift and go to state 34
    ID              shift and go to state 19

    a_fact                         shift and go to state 92
    varref                         shift and go to state 31

state 90

    (18) else_stmt -> ELSE . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (19) assignment -> . varref ASSIGN l_expr
    (46) read -> . READ varlist
    (47) write -> . WRITE expr_list
    (14) while -> . WHILE l_expr block
    (15) repeat -> . REPEAT stmt_list UNTIL l_expr
    (12) block -> . BEGIN stmt_list END
    (13) foreach -> . FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
    (16) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt                           shift and go to state 93
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 91

    (16) if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt .

    SEMICOLON       reduce using rule 16 (if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt .)
    UNTIL           reduce using rule 16 (if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt .)
    END             reduce using rule 16 (if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt .)
    ELSE            reduce using rule 16 (if_stmt -> IF l_expr THEN stmt_list ELSE else_stmt .)


state 92

    (13) foreach -> FOREACH ID IN LPAREN a_fact COLON a_fact . RPAREN stmt

    RPAREN          shift and go to state 94


state 93

    (18) else_stmt -> ELSE stmt .

    SEMICOLON       reduce using rule 18 (else_stmt -> ELSE stmt .)
    UNTIL           reduce using rule 18 (else_stmt -> ELSE stmt .)
    END             reduce using rule 18 (else_stmt -> ELSE stmt .)
    ELSE            reduce using rule 18 (else_stmt -> ELSE stmt .)


state 94

    (13) foreach -> FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (19) assignment -> . varref ASSIGN l_expr
    (46) read -> . READ varlist
    (47) write -> . WRITE expr_list
    (14) while -> . WHILE l_expr block
    (15) repeat -> . REPEAT stmt_list UNTIL l_expr
    (12) block -> . BEGIN stmt_list END
    (13) foreach -> . FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt
    (16) if_stmt -> . IF l_expr THEN stmt_list ELSE else_stmt
    (31) varref -> . ID
    (32) varref -> . varref LBRACK a_expr RBRACK

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt                           shift and go to state 95
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 95

    (13) foreach -> FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt .

    SEMICOLON       reduce using rule 13 (foreach -> FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt .)
    UNTIL           reduce using rule 13 (foreach -> FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt .)
    END             reduce using rule 13 (foreach -> FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt .)
    ELSE            reduce using rule 13 (foreach -> FOREACH ID IN LPAREN a_fact COLON a_fact RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAREN in state 66 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 88 resolved as shift
