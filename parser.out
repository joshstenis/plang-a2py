Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt_list SEMICOLON
Rule 2     stmt_list -> stmt_list SEMICOLON stmt
Rule 3     stmt_list -> stmt
Rule 4     stmt -> assignment
Rule 5     stmt -> read
Rule 6     stmt -> write
Rule 7     stmt -> while
Rule 8     stmt -> repeat
Rule 9     stmt -> block
Rule 10    stmt -> foreach
Rule 11    stmt -> if_stmt
Rule 12    assignment -> varref ASSIGN l_expr
Rule 13    read -> READ varlist
Rule 14    write -> WRITE expr_list
Rule 15    while -> WHILE l_expr block
Rule 16    repeat -> REPEAT stmt_list UNTIL l_expr
Rule 17    block -> BEGIN stmt_list END
Rule 18    foreach -> FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
Rule 19    if_stmt -> IF l_expr THEN stmt_list else_stmt
Rule 20    else_stmt -> <empty>
Rule 21    else_stmt -> ELSE stmt
Rule 22    a_expr -> a_expr a_op a_expr
Rule 23    a_expr -> SUB a_expr
Rule 24    a_expr -> NUM
Rule 25    a_expr -> varref
Rule 26    a_expr -> LITERAL_STR
Rule 27    a_expr -> LPAREN a_expr RPAREN
Rule 28    a_op -> ADD
Rule 29    a_op -> SUB
Rule 30    a_op -> MUL
Rule 31    a_op -> DIV
Rule 32    varref -> varref LBRACK a_expr RBRACK
Rule 33    varref -> ID
Rule 34    l_expr -> LPAREN l_expr RPAREN
Rule 35    l_expr -> l_expr l_op l_expr
Rule 36    l_expr -> l_expr oprel a_expr
Rule 37    l_expr -> a_expr
Rule 38    l_op -> OR
Rule 39    l_op -> AND
Rule 40    oprel -> LT
Rule 41    oprel -> GT
Rule 42    oprel -> LEQ
Rule 43    oprel -> GEQ
Rule 44    oprel -> EQ
Rule 45    oprel -> NEQ
Rule 46    varlist -> varlist COMMA varlist
Rule 47    varlist -> varref
Rule 48    expr_list -> a_expr
Rule 49    expr_list -> expr_list COMMA a_expr

Terminals, with rules where they appear

ADD                  : 28
AND                  : 39
ASSIGN               : 12
BEGIN                : 17
COLON                : 18
COMMA                : 46 49
COMMENT              : 
DIV                  : 31
ELSE                 : 21
END                  : 17
EQ                   : 44
FOREACH              : 18
GEQ                  : 43
GT                   : 41
ID                   : 18 33
IF                   : 19
IN                   : 18
LBRACK               : 32
LEQ                  : 42
LITERAL_STR          : 26
LPAREN               : 18 27 34
LT                   : 40
MUL                  : 30
NEQ                  : 45
NUM                  : 24
OR                   : 38
RBRACK               : 32
READ                 : 13
REPEAT               : 16
RPAREN               : 18 27 34
SEMICOLON            : 1 2
SUB                  : 23 29
THEN                 : 19
UNTIL                : 16
WHILE                : 15
WRITE                : 14
error                : 

Nonterminals, with rules where they appear

a_expr               : 18 18 22 22 23 27 32 36 37 48 49
a_op                 : 22
assignment           : 4
block                : 9 15
else_stmt            : 19
expr_list            : 14 49
foreach              : 10
if_stmt              : 11
l_expr               : 12 15 16 19 34 35 35 36
l_op                 : 35
oprel                : 36
program              : 0
read                 : 5
repeat               : 8
stmt                 : 2 3 18 21
stmt_list            : 1 2 16 17 19
varlist              : 13 46 46
varref               : 12 25 32 47
while                : 7
write                : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt_list SEMICOLON
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list else_stmt
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt_list . SEMICOLON
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    SEMICOLON       shift and go to state 21


state 3

    (3) stmt_list -> stmt .

    SEMICOLON       reduce using rule 3 (stmt_list -> stmt .)
    UNTIL           reduce using rule 3 (stmt_list -> stmt .)
    END             reduce using rule 3 (stmt_list -> stmt .)
    ELSE            reduce using rule 3 (stmt_list -> stmt .)


state 4

    (4) stmt -> assignment .

    SEMICOLON       reduce using rule 4 (stmt -> assignment .)
    UNTIL           reduce using rule 4 (stmt -> assignment .)
    END             reduce using rule 4 (stmt -> assignment .)
    ELSE            reduce using rule 4 (stmt -> assignment .)


state 5

    (5) stmt -> read .

    SEMICOLON       reduce using rule 5 (stmt -> read .)
    UNTIL           reduce using rule 5 (stmt -> read .)
    END             reduce using rule 5 (stmt -> read .)
    ELSE            reduce using rule 5 (stmt -> read .)


state 6

    (6) stmt -> write .

    SEMICOLON       reduce using rule 6 (stmt -> write .)
    UNTIL           reduce using rule 6 (stmt -> write .)
    END             reduce using rule 6 (stmt -> write .)
    ELSE            reduce using rule 6 (stmt -> write .)


state 7

    (7) stmt -> while .

    SEMICOLON       reduce using rule 7 (stmt -> while .)
    UNTIL           reduce using rule 7 (stmt -> while .)
    END             reduce using rule 7 (stmt -> while .)
    ELSE            reduce using rule 7 (stmt -> while .)


state 8

    (8) stmt -> repeat .

    SEMICOLON       reduce using rule 8 (stmt -> repeat .)
    UNTIL           reduce using rule 8 (stmt -> repeat .)
    END             reduce using rule 8 (stmt -> repeat .)
    ELSE            reduce using rule 8 (stmt -> repeat .)


state 9

    (9) stmt -> block .

    SEMICOLON       reduce using rule 9 (stmt -> block .)
    UNTIL           reduce using rule 9 (stmt -> block .)
    END             reduce using rule 9 (stmt -> block .)
    ELSE            reduce using rule 9 (stmt -> block .)


state 10

    (10) stmt -> foreach .

    SEMICOLON       reduce using rule 10 (stmt -> foreach .)
    UNTIL           reduce using rule 10 (stmt -> foreach .)
    END             reduce using rule 10 (stmt -> foreach .)
    ELSE            reduce using rule 10 (stmt -> foreach .)


state 11

    (11) stmt -> if_stmt .

    SEMICOLON       reduce using rule 11 (stmt -> if_stmt .)
    UNTIL           reduce using rule 11 (stmt -> if_stmt .)
    END             reduce using rule 11 (stmt -> if_stmt .)
    ELSE            reduce using rule 11 (stmt -> if_stmt .)


state 12

    (12) assignment -> varref . ASSIGN l_expr
    (32) varref -> varref . LBRACK a_expr RBRACK

    ASSIGN          shift and go to state 22
    LBRACK          shift and go to state 23


state 13

    (13) read -> READ . varlist
    (46) varlist -> . varlist COMMA varlist
    (47) varlist -> . varref
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    ID              shift and go to state 19

    varlist                        shift and go to state 24
    varref                         shift and go to state 25

state 14

    (14) write -> WRITE . expr_list
    (48) expr_list -> . a_expr
    (49) expr_list -> . expr_list COMMA a_expr
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . NUM
    (25) a_expr -> . varref
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    SUB             shift and go to state 28
    NUM             shift and go to state 29
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    expr_list                      shift and go to state 26
    a_expr                         shift and go to state 27
    varref                         shift and go to state 30

state 15

    (15) while -> WHILE . l_expr block
    (34) l_expr -> . LPAREN l_expr RPAREN
    (35) l_expr -> . l_expr l_op l_expr
    (36) l_expr -> . l_expr oprel a_expr
    (37) l_expr -> . a_expr
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . NUM
    (25) a_expr -> . varref
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    LPAREN          shift and go to state 34
    SUB             shift and go to state 28
    NUM             shift and go to state 29
    LITERAL_STR     shift and go to state 31
    ID              shift and go to state 19

    l_expr                         shift and go to state 33
    a_expr                         shift and go to state 35
    varref                         shift and go to state 30

state 16

    (16) repeat -> REPEAT . stmt_list UNTIL l_expr
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list else_stmt
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt_list                      shift and go to state 36
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 17

    (17) block -> BEGIN . stmt_list END
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list else_stmt
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt_list                      shift and go to state 37
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 18

    (18) foreach -> FOREACH . ID IN LPAREN a_expr COLON a_expr RPAREN stmt

    ID              shift and go to state 38


state 19

    (33) varref -> ID .

    ASSIGN          reduce using rule 33 (varref -> ID .)
    LBRACK          reduce using rule 33 (varref -> ID .)
    COMMA           reduce using rule 33 (varref -> ID .)
    SEMICOLON       reduce using rule 33 (varref -> ID .)
    UNTIL           reduce using rule 33 (varref -> ID .)
    END             reduce using rule 33 (varref -> ID .)
    ELSE            reduce using rule 33 (varref -> ID .)
    ADD             reduce using rule 33 (varref -> ID .)
    SUB             reduce using rule 33 (varref -> ID .)
    MUL             reduce using rule 33 (varref -> ID .)
    DIV             reduce using rule 33 (varref -> ID .)
    BEGIN           reduce using rule 33 (varref -> ID .)
    OR              reduce using rule 33 (varref -> ID .)
    AND             reduce using rule 33 (varref -> ID .)
    LT              reduce using rule 33 (varref -> ID .)
    GT              reduce using rule 33 (varref -> ID .)
    LEQ             reduce using rule 33 (varref -> ID .)
    GEQ             reduce using rule 33 (varref -> ID .)
    EQ              reduce using rule 33 (varref -> ID .)
    NEQ             reduce using rule 33 (varref -> ID .)
    THEN            reduce using rule 33 (varref -> ID .)
    RBRACK          reduce using rule 33 (varref -> ID .)
    RPAREN          reduce using rule 33 (varref -> ID .)
    COLON           reduce using rule 33 (varref -> ID .)


state 20

    (19) if_stmt -> IF . l_expr THEN stmt_list else_stmt
    (34) l_expr -> . LPAREN l_expr RPAREN
    (35) l_expr -> . l_expr l_op l_expr
    (36) l_expr -> . l_expr oprel a_expr
    (37) l_expr -> . a_expr
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . NUM
    (25) a_expr -> . varref
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    LPAREN          shift and go to state 34
    SUB             shift and go to state 28
    NUM             shift and go to state 29
    LITERAL_STR     shift and go to state 31
    ID              shift and go to state 19

    l_expr                         shift and go to state 39
    a_expr                         shift and go to state 35
    varref                         shift and go to state 30

state 21

    (1) program -> stmt_list SEMICOLON .
    (2) stmt_list -> stmt_list SEMICOLON . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list else_stmt
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    $end            reduce using rule 1 (program -> stmt_list SEMICOLON .)
    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt                           shift and go to state 40
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 22

    (12) assignment -> varref ASSIGN . l_expr
    (34) l_expr -> . LPAREN l_expr RPAREN
    (35) l_expr -> . l_expr l_op l_expr
    (36) l_expr -> . l_expr oprel a_expr
    (37) l_expr -> . a_expr
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . NUM
    (25) a_expr -> . varref
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    LPAREN          shift and go to state 34
    SUB             shift and go to state 28
    NUM             shift and go to state 29
    LITERAL_STR     shift and go to state 31
    ID              shift and go to state 19

    varref                         shift and go to state 30
    l_expr                         shift and go to state 41
    a_expr                         shift and go to state 35

state 23

    (32) varref -> varref LBRACK . a_expr RBRACK
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . NUM
    (25) a_expr -> . varref
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    SUB             shift and go to state 28
    NUM             shift and go to state 29
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    varref                         shift and go to state 30
    a_expr                         shift and go to state 42

state 24

    (13) read -> READ varlist .
    (46) varlist -> varlist . COMMA varlist

    SEMICOLON       reduce using rule 13 (read -> READ varlist .)
    UNTIL           reduce using rule 13 (read -> READ varlist .)
    END             reduce using rule 13 (read -> READ varlist .)
    ELSE            reduce using rule 13 (read -> READ varlist .)
    COMMA           shift and go to state 43


state 25

    (47) varlist -> varref .
    (32) varref -> varref . LBRACK a_expr RBRACK

    COMMA           reduce using rule 47 (varlist -> varref .)
    SEMICOLON       reduce using rule 47 (varlist -> varref .)
    UNTIL           reduce using rule 47 (varlist -> varref .)
    END             reduce using rule 47 (varlist -> varref .)
    ELSE            reduce using rule 47 (varlist -> varref .)
    LBRACK          shift and go to state 23


state 26

    (14) write -> WRITE expr_list .
    (49) expr_list -> expr_list . COMMA a_expr

    SEMICOLON       reduce using rule 14 (write -> WRITE expr_list .)
    UNTIL           reduce using rule 14 (write -> WRITE expr_list .)
    END             reduce using rule 14 (write -> WRITE expr_list .)
    ELSE            reduce using rule 14 (write -> WRITE expr_list .)
    COMMA           shift and go to state 44


state 27

    (48) expr_list -> a_expr .
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

    COMMA           reduce using rule 48 (expr_list -> a_expr .)
    SEMICOLON       reduce using rule 48 (expr_list -> a_expr .)
    UNTIL           reduce using rule 48 (expr_list -> a_expr .)
    END             reduce using rule 48 (expr_list -> a_expr .)
    ELSE            reduce using rule 48 (expr_list -> a_expr .)
    ADD             shift and go to state 46
    SUB             shift and go to state 47
    MUL             shift and go to state 48
    DIV             shift and go to state 49

    a_op                           shift and go to state 45

state 28

    (23) a_expr -> SUB . a_expr
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . NUM
    (25) a_expr -> . varref
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    SUB             shift and go to state 28
    NUM             shift and go to state 29
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    a_expr                         shift and go to state 50
    varref                         shift and go to state 30

state 29

    (24) a_expr -> NUM .

    ADD             reduce using rule 24 (a_expr -> NUM .)
    SUB             reduce using rule 24 (a_expr -> NUM .)
    MUL             reduce using rule 24 (a_expr -> NUM .)
    DIV             reduce using rule 24 (a_expr -> NUM .)
    COMMA           reduce using rule 24 (a_expr -> NUM .)
    SEMICOLON       reduce using rule 24 (a_expr -> NUM .)
    UNTIL           reduce using rule 24 (a_expr -> NUM .)
    END             reduce using rule 24 (a_expr -> NUM .)
    ELSE            reduce using rule 24 (a_expr -> NUM .)
    BEGIN           reduce using rule 24 (a_expr -> NUM .)
    OR              reduce using rule 24 (a_expr -> NUM .)
    AND             reduce using rule 24 (a_expr -> NUM .)
    LT              reduce using rule 24 (a_expr -> NUM .)
    GT              reduce using rule 24 (a_expr -> NUM .)
    LEQ             reduce using rule 24 (a_expr -> NUM .)
    GEQ             reduce using rule 24 (a_expr -> NUM .)
    EQ              reduce using rule 24 (a_expr -> NUM .)
    NEQ             reduce using rule 24 (a_expr -> NUM .)
    THEN            reduce using rule 24 (a_expr -> NUM .)
    RBRACK          reduce using rule 24 (a_expr -> NUM .)
    RPAREN          reduce using rule 24 (a_expr -> NUM .)
    COLON           reduce using rule 24 (a_expr -> NUM .)


state 30

    (25) a_expr -> varref .
    (32) varref -> varref . LBRACK a_expr RBRACK

    ADD             reduce using rule 25 (a_expr -> varref .)
    SUB             reduce using rule 25 (a_expr -> varref .)
    MUL             reduce using rule 25 (a_expr -> varref .)
    DIV             reduce using rule 25 (a_expr -> varref .)
    COMMA           reduce using rule 25 (a_expr -> varref .)
    SEMICOLON       reduce using rule 25 (a_expr -> varref .)
    UNTIL           reduce using rule 25 (a_expr -> varref .)
    END             reduce using rule 25 (a_expr -> varref .)
    ELSE            reduce using rule 25 (a_expr -> varref .)
    BEGIN           reduce using rule 25 (a_expr -> varref .)
    OR              reduce using rule 25 (a_expr -> varref .)
    AND             reduce using rule 25 (a_expr -> varref .)
    LT              reduce using rule 25 (a_expr -> varref .)
    GT              reduce using rule 25 (a_expr -> varref .)
    LEQ             reduce using rule 25 (a_expr -> varref .)
    GEQ             reduce using rule 25 (a_expr -> varref .)
    EQ              reduce using rule 25 (a_expr -> varref .)
    NEQ             reduce using rule 25 (a_expr -> varref .)
    THEN            reduce using rule 25 (a_expr -> varref .)
    RBRACK          reduce using rule 25 (a_expr -> varref .)
    RPAREN          reduce using rule 25 (a_expr -> varref .)
    COLON           reduce using rule 25 (a_expr -> varref .)
    LBRACK          shift and go to state 23


state 31

    (26) a_expr -> LITERAL_STR .

    ADD             reduce using rule 26 (a_expr -> LITERAL_STR .)
    SUB             reduce using rule 26 (a_expr -> LITERAL_STR .)
    MUL             reduce using rule 26 (a_expr -> LITERAL_STR .)
    DIV             reduce using rule 26 (a_expr -> LITERAL_STR .)
    COMMA           reduce using rule 26 (a_expr -> LITERAL_STR .)
    SEMICOLON       reduce using rule 26 (a_expr -> LITERAL_STR .)
    UNTIL           reduce using rule 26 (a_expr -> LITERAL_STR .)
    END             reduce using rule 26 (a_expr -> LITERAL_STR .)
    ELSE            reduce using rule 26 (a_expr -> LITERAL_STR .)
    BEGIN           reduce using rule 26 (a_expr -> LITERAL_STR .)
    OR              reduce using rule 26 (a_expr -> LITERAL_STR .)
    AND             reduce using rule 26 (a_expr -> LITERAL_STR .)
    LT              reduce using rule 26 (a_expr -> LITERAL_STR .)
    GT              reduce using rule 26 (a_expr -> LITERAL_STR .)
    LEQ             reduce using rule 26 (a_expr -> LITERAL_STR .)
    GEQ             reduce using rule 26 (a_expr -> LITERAL_STR .)
    EQ              reduce using rule 26 (a_expr -> LITERAL_STR .)
    NEQ             reduce using rule 26 (a_expr -> LITERAL_STR .)
    THEN            reduce using rule 26 (a_expr -> LITERAL_STR .)
    RBRACK          reduce using rule 26 (a_expr -> LITERAL_STR .)
    RPAREN          reduce using rule 26 (a_expr -> LITERAL_STR .)
    COLON           reduce using rule 26 (a_expr -> LITERAL_STR .)


state 32

    (27) a_expr -> LPAREN . a_expr RPAREN
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . NUM
    (25) a_expr -> . varref
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    SUB             shift and go to state 28
    NUM             shift and go to state 29
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    a_expr                         shift and go to state 51
    varref                         shift and go to state 30

state 33

    (15) while -> WHILE l_expr . block
    (35) l_expr -> l_expr . l_op l_expr
    (36) l_expr -> l_expr . oprel a_expr
    (17) block -> . BEGIN stmt_list END
    (38) l_op -> . OR
    (39) l_op -> . AND
    (40) oprel -> . LT
    (41) oprel -> . GT
    (42) oprel -> . LEQ
    (43) oprel -> . GEQ
    (44) oprel -> . EQ
    (45) oprel -> . NEQ

    BEGIN           shift and go to state 17
    OR              shift and go to state 55
    AND             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    LEQ             shift and go to state 59
    GEQ             shift and go to state 60
    EQ              shift and go to state 61
    NEQ             shift and go to state 62

    block                          shift and go to state 52
    l_op                           shift and go to state 53
    oprel                          shift and go to state 54

state 34

    (34) l_expr -> LPAREN . l_expr RPAREN
    (27) a_expr -> LPAREN . a_expr RPAREN
    (34) l_expr -> . LPAREN l_expr RPAREN
    (35) l_expr -> . l_expr l_op l_expr
    (36) l_expr -> . l_expr oprel a_expr
    (37) l_expr -> . a_expr
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . NUM
    (25) a_expr -> . varref
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    LPAREN          shift and go to state 34
    SUB             shift and go to state 28
    NUM             shift and go to state 29
    LITERAL_STR     shift and go to state 31
    ID              shift and go to state 19

    l_expr                         shift and go to state 63
    a_expr                         shift and go to state 64
    varref                         shift and go to state 30

state 35

    (37) l_expr -> a_expr .
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

    BEGIN           reduce using rule 37 (l_expr -> a_expr .)
    OR              reduce using rule 37 (l_expr -> a_expr .)
    AND             reduce using rule 37 (l_expr -> a_expr .)
    LT              reduce using rule 37 (l_expr -> a_expr .)
    GT              reduce using rule 37 (l_expr -> a_expr .)
    LEQ             reduce using rule 37 (l_expr -> a_expr .)
    GEQ             reduce using rule 37 (l_expr -> a_expr .)
    EQ              reduce using rule 37 (l_expr -> a_expr .)
    NEQ             reduce using rule 37 (l_expr -> a_expr .)
    THEN            reduce using rule 37 (l_expr -> a_expr .)
    SEMICOLON       reduce using rule 37 (l_expr -> a_expr .)
    UNTIL           reduce using rule 37 (l_expr -> a_expr .)
    END             reduce using rule 37 (l_expr -> a_expr .)
    ELSE            reduce using rule 37 (l_expr -> a_expr .)
    RPAREN          reduce using rule 37 (l_expr -> a_expr .)
    ADD             shift and go to state 46
    SUB             shift and go to state 47
    MUL             shift and go to state 48
    DIV             shift and go to state 49

    a_op                           shift and go to state 45

state 36

    (16) repeat -> REPEAT stmt_list . UNTIL l_expr
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    UNTIL           shift and go to state 65
    SEMICOLON       shift and go to state 66


state 37

    (17) block -> BEGIN stmt_list . END
    (2) stmt_list -> stmt_list . SEMICOLON stmt

    END             shift and go to state 67
    SEMICOLON       shift and go to state 66


state 38

    (18) foreach -> FOREACH ID . IN LPAREN a_expr COLON a_expr RPAREN stmt

    IN              shift and go to state 68


state 39

    (19) if_stmt -> IF l_expr . THEN stmt_list else_stmt
    (35) l_expr -> l_expr . l_op l_expr
    (36) l_expr -> l_expr . oprel a_expr
    (38) l_op -> . OR
    (39) l_op -> . AND
    (40) oprel -> . LT
    (41) oprel -> . GT
    (42) oprel -> . LEQ
    (43) oprel -> . GEQ
    (44) oprel -> . EQ
    (45) oprel -> . NEQ

    THEN            shift and go to state 69
    OR              shift and go to state 55
    AND             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    LEQ             shift and go to state 59
    GEQ             shift and go to state 60
    EQ              shift and go to state 61
    NEQ             shift and go to state 62

    l_op                           shift and go to state 53
    oprel                          shift and go to state 54

state 40

    (2) stmt_list -> stmt_list SEMICOLON stmt .

    SEMICOLON       reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)
    UNTIL           reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)
    END             reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)
    ELSE            reduce using rule 2 (stmt_list -> stmt_list SEMICOLON stmt .)


state 41

    (12) assignment -> varref ASSIGN l_expr .
    (35) l_expr -> l_expr . l_op l_expr
    (36) l_expr -> l_expr . oprel a_expr
    (38) l_op -> . OR
    (39) l_op -> . AND
    (40) oprel -> . LT
    (41) oprel -> . GT
    (42) oprel -> . LEQ
    (43) oprel -> . GEQ
    (44) oprel -> . EQ
    (45) oprel -> . NEQ

    SEMICOLON       reduce using rule 12 (assignment -> varref ASSIGN l_expr .)
    UNTIL           reduce using rule 12 (assignment -> varref ASSIGN l_expr .)
    END             reduce using rule 12 (assignment -> varref ASSIGN l_expr .)
    ELSE            reduce using rule 12 (assignment -> varref ASSIGN l_expr .)
    OR              shift and go to state 55
    AND             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    LEQ             shift and go to state 59
    GEQ             shift and go to state 60
    EQ              shift and go to state 61
    NEQ             shift and go to state 62

    l_op                           shift and go to state 53
    oprel                          shift and go to state 54

state 42

    (32) varref -> varref LBRACK a_expr . RBRACK
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

    RBRACK          shift and go to state 70
    ADD             shift and go to state 46
    SUB             shift and go to state 47
    MUL             shift and go to state 48
    DIV             shift and go to state 49

    a_op                           shift and go to state 45

state 43

    (46) varlist -> varlist COMMA . varlist
    (46) varlist -> . varlist COMMA varlist
    (47) varlist -> . varref
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    ID              shift and go to state 19

    varlist                        shift and go to state 71
    varref                         shift and go to state 25

state 44

    (49) expr_list -> expr_list COMMA . a_expr
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . NUM
    (25) a_expr -> . varref
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    SUB             shift and go to state 28
    NUM             shift and go to state 29
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    a_expr                         shift and go to state 72
    varref                         shift and go to state 30

state 45

    (22) a_expr -> a_expr a_op . a_expr
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . NUM
    (25) a_expr -> . varref
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    SUB             shift and go to state 28
    NUM             shift and go to state 29
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    a_expr                         shift and go to state 73
    varref                         shift and go to state 30

state 46

    (28) a_op -> ADD .

    SUB             reduce using rule 28 (a_op -> ADD .)
    NUM             reduce using rule 28 (a_op -> ADD .)
    LITERAL_STR     reduce using rule 28 (a_op -> ADD .)
    LPAREN          reduce using rule 28 (a_op -> ADD .)
    ID              reduce using rule 28 (a_op -> ADD .)


state 47

    (29) a_op -> SUB .

    SUB             reduce using rule 29 (a_op -> SUB .)
    NUM             reduce using rule 29 (a_op -> SUB .)
    LITERAL_STR     reduce using rule 29 (a_op -> SUB .)
    LPAREN          reduce using rule 29 (a_op -> SUB .)
    ID              reduce using rule 29 (a_op -> SUB .)


state 48

    (30) a_op -> MUL .

    SUB             reduce using rule 30 (a_op -> MUL .)
    NUM             reduce using rule 30 (a_op -> MUL .)
    LITERAL_STR     reduce using rule 30 (a_op -> MUL .)
    LPAREN          reduce using rule 30 (a_op -> MUL .)
    ID              reduce using rule 30 (a_op -> MUL .)


state 49

    (31) a_op -> DIV .

    SUB             reduce using rule 31 (a_op -> DIV .)
    NUM             reduce using rule 31 (a_op -> DIV .)
    LITERAL_STR     reduce using rule 31 (a_op -> DIV .)
    LPAREN          reduce using rule 31 (a_op -> DIV .)
    ID              reduce using rule 31 (a_op -> DIV .)


state 50

    (23) a_expr -> SUB a_expr .
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    COMMA           reduce using rule 23 (a_expr -> SUB a_expr .)
    SEMICOLON       reduce using rule 23 (a_expr -> SUB a_expr .)
    UNTIL           reduce using rule 23 (a_expr -> SUB a_expr .)
    END             reduce using rule 23 (a_expr -> SUB a_expr .)
    ELSE            reduce using rule 23 (a_expr -> SUB a_expr .)
    BEGIN           reduce using rule 23 (a_expr -> SUB a_expr .)
    OR              reduce using rule 23 (a_expr -> SUB a_expr .)
    AND             reduce using rule 23 (a_expr -> SUB a_expr .)
    LT              reduce using rule 23 (a_expr -> SUB a_expr .)
    GT              reduce using rule 23 (a_expr -> SUB a_expr .)
    LEQ             reduce using rule 23 (a_expr -> SUB a_expr .)
    GEQ             reduce using rule 23 (a_expr -> SUB a_expr .)
    EQ              reduce using rule 23 (a_expr -> SUB a_expr .)
    NEQ             reduce using rule 23 (a_expr -> SUB a_expr .)
    THEN            reduce using rule 23 (a_expr -> SUB a_expr .)
    RBRACK          reduce using rule 23 (a_expr -> SUB a_expr .)
    RPAREN          reduce using rule 23 (a_expr -> SUB a_expr .)
    COLON           reduce using rule 23 (a_expr -> SUB a_expr .)
    ADD             shift and go to state 46
    SUB             shift and go to state 47
    MUL             shift and go to state 48
    DIV             shift and go to state 49

  ! ADD             [ reduce using rule 23 (a_expr -> SUB a_expr .) ]
  ! SUB             [ reduce using rule 23 (a_expr -> SUB a_expr .) ]
  ! MUL             [ reduce using rule 23 (a_expr -> SUB a_expr .) ]
  ! DIV             [ reduce using rule 23 (a_expr -> SUB a_expr .) ]

    a_op                           shift and go to state 45

state 51

    (27) a_expr -> LPAREN a_expr . RPAREN
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

    RPAREN          shift and go to state 74
    ADD             shift and go to state 46
    SUB             shift and go to state 47
    MUL             shift and go to state 48
    DIV             shift and go to state 49

    a_op                           shift and go to state 45

state 52

    (15) while -> WHILE l_expr block .

    SEMICOLON       reduce using rule 15 (while -> WHILE l_expr block .)
    UNTIL           reduce using rule 15 (while -> WHILE l_expr block .)
    END             reduce using rule 15 (while -> WHILE l_expr block .)
    ELSE            reduce using rule 15 (while -> WHILE l_expr block .)


state 53

    (35) l_expr -> l_expr l_op . l_expr
    (34) l_expr -> . LPAREN l_expr RPAREN
    (35) l_expr -> . l_expr l_op l_expr
    (36) l_expr -> . l_expr oprel a_expr
    (37) l_expr -> . a_expr
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . NUM
    (25) a_expr -> . varref
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    LPAREN          shift and go to state 34
    SUB             shift and go to state 28
    NUM             shift and go to state 29
    LITERAL_STR     shift and go to state 31
    ID              shift and go to state 19

    l_expr                         shift and go to state 75
    a_expr                         shift and go to state 35
    varref                         shift and go to state 30

state 54

    (36) l_expr -> l_expr oprel . a_expr
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . NUM
    (25) a_expr -> . varref
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    SUB             shift and go to state 28
    NUM             shift and go to state 29
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    a_expr                         shift and go to state 76
    varref                         shift and go to state 30

state 55

    (38) l_op -> OR .

    LPAREN          reduce using rule 38 (l_op -> OR .)
    SUB             reduce using rule 38 (l_op -> OR .)
    NUM             reduce using rule 38 (l_op -> OR .)
    LITERAL_STR     reduce using rule 38 (l_op -> OR .)
    ID              reduce using rule 38 (l_op -> OR .)


state 56

    (39) l_op -> AND .

    LPAREN          reduce using rule 39 (l_op -> AND .)
    SUB             reduce using rule 39 (l_op -> AND .)
    NUM             reduce using rule 39 (l_op -> AND .)
    LITERAL_STR     reduce using rule 39 (l_op -> AND .)
    ID              reduce using rule 39 (l_op -> AND .)


state 57

    (40) oprel -> LT .

    SUB             reduce using rule 40 (oprel -> LT .)
    NUM             reduce using rule 40 (oprel -> LT .)
    LITERAL_STR     reduce using rule 40 (oprel -> LT .)
    LPAREN          reduce using rule 40 (oprel -> LT .)
    ID              reduce using rule 40 (oprel -> LT .)


state 58

    (41) oprel -> GT .

    SUB             reduce using rule 41 (oprel -> GT .)
    NUM             reduce using rule 41 (oprel -> GT .)
    LITERAL_STR     reduce using rule 41 (oprel -> GT .)
    LPAREN          reduce using rule 41 (oprel -> GT .)
    ID              reduce using rule 41 (oprel -> GT .)


state 59

    (42) oprel -> LEQ .

    SUB             reduce using rule 42 (oprel -> LEQ .)
    NUM             reduce using rule 42 (oprel -> LEQ .)
    LITERAL_STR     reduce using rule 42 (oprel -> LEQ .)
    LPAREN          reduce using rule 42 (oprel -> LEQ .)
    ID              reduce using rule 42 (oprel -> LEQ .)


state 60

    (43) oprel -> GEQ .

    SUB             reduce using rule 43 (oprel -> GEQ .)
    NUM             reduce using rule 43 (oprel -> GEQ .)
    LITERAL_STR     reduce using rule 43 (oprel -> GEQ .)
    LPAREN          reduce using rule 43 (oprel -> GEQ .)
    ID              reduce using rule 43 (oprel -> GEQ .)


state 61

    (44) oprel -> EQ .

    SUB             reduce using rule 44 (oprel -> EQ .)
    NUM             reduce using rule 44 (oprel -> EQ .)
    LITERAL_STR     reduce using rule 44 (oprel -> EQ .)
    LPAREN          reduce using rule 44 (oprel -> EQ .)
    ID              reduce using rule 44 (oprel -> EQ .)


state 62

    (45) oprel -> NEQ .

    SUB             reduce using rule 45 (oprel -> NEQ .)
    NUM             reduce using rule 45 (oprel -> NEQ .)
    LITERAL_STR     reduce using rule 45 (oprel -> NEQ .)
    LPAREN          reduce using rule 45 (oprel -> NEQ .)
    ID              reduce using rule 45 (oprel -> NEQ .)


state 63

    (34) l_expr -> LPAREN l_expr . RPAREN
    (35) l_expr -> l_expr . l_op l_expr
    (36) l_expr -> l_expr . oprel a_expr
    (38) l_op -> . OR
    (39) l_op -> . AND
    (40) oprel -> . LT
    (41) oprel -> . GT
    (42) oprel -> . LEQ
    (43) oprel -> . GEQ
    (44) oprel -> . EQ
    (45) oprel -> . NEQ

    RPAREN          shift and go to state 77
    OR              shift and go to state 55
    AND             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    LEQ             shift and go to state 59
    GEQ             shift and go to state 60
    EQ              shift and go to state 61
    NEQ             shift and go to state 62

    l_op                           shift and go to state 53
    oprel                          shift and go to state 54

state 64

    (27) a_expr -> LPAREN a_expr . RPAREN
    (37) l_expr -> a_expr .
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 74
    OR              reduce using rule 37 (l_expr -> a_expr .)
    AND             reduce using rule 37 (l_expr -> a_expr .)
    LT              reduce using rule 37 (l_expr -> a_expr .)
    GT              reduce using rule 37 (l_expr -> a_expr .)
    LEQ             reduce using rule 37 (l_expr -> a_expr .)
    GEQ             reduce using rule 37 (l_expr -> a_expr .)
    EQ              reduce using rule 37 (l_expr -> a_expr .)
    NEQ             reduce using rule 37 (l_expr -> a_expr .)
    ADD             shift and go to state 46
    SUB             shift and go to state 47
    MUL             shift and go to state 48
    DIV             shift and go to state 49

  ! RPAREN          [ reduce using rule 37 (l_expr -> a_expr .) ]

    a_op                           shift and go to state 45

state 65

    (16) repeat -> REPEAT stmt_list UNTIL . l_expr
    (34) l_expr -> . LPAREN l_expr RPAREN
    (35) l_expr -> . l_expr l_op l_expr
    (36) l_expr -> . l_expr oprel a_expr
    (37) l_expr -> . a_expr
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . NUM
    (25) a_expr -> . varref
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    LPAREN          shift and go to state 34
    SUB             shift and go to state 28
    NUM             shift and go to state 29
    LITERAL_STR     shift and go to state 31
    ID              shift and go to state 19

    l_expr                         shift and go to state 78
    a_expr                         shift and go to state 35
    varref                         shift and go to state 30

state 66

    (2) stmt_list -> stmt_list SEMICOLON . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list else_stmt
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt                           shift and go to state 40
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 67

    (17) block -> BEGIN stmt_list END .

    SEMICOLON       reduce using rule 17 (block -> BEGIN stmt_list END .)
    UNTIL           reduce using rule 17 (block -> BEGIN stmt_list END .)
    END             reduce using rule 17 (block -> BEGIN stmt_list END .)
    ELSE            reduce using rule 17 (block -> BEGIN stmt_list END .)


state 68

    (18) foreach -> FOREACH ID IN . LPAREN a_expr COLON a_expr RPAREN stmt

    LPAREN          shift and go to state 79


state 69

    (19) if_stmt -> IF l_expr THEN . stmt_list else_stmt
    (2) stmt_list -> . stmt_list SEMICOLON stmt
    (3) stmt_list -> . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list else_stmt
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt_list                      shift and go to state 80
    stmt                           shift and go to state 3
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 70

    (32) varref -> varref LBRACK a_expr RBRACK .

    ASSIGN          reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    LBRACK          reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    COMMA           reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    SEMICOLON       reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    UNTIL           reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    END             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    ELSE            reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    ADD             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    SUB             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    MUL             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    DIV             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    BEGIN           reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    OR              reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    AND             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    LT              reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    GT              reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    LEQ             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    GEQ             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    EQ              reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    NEQ             reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    THEN            reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    RBRACK          reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    RPAREN          reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)
    COLON           reduce using rule 32 (varref -> varref LBRACK a_expr RBRACK .)


state 71

    (46) varlist -> varlist COMMA varlist .
    (46) varlist -> varlist . COMMA varlist

  ! shift/reduce conflict for COMMA resolved as shift
    SEMICOLON       reduce using rule 46 (varlist -> varlist COMMA varlist .)
    UNTIL           reduce using rule 46 (varlist -> varlist COMMA varlist .)
    END             reduce using rule 46 (varlist -> varlist COMMA varlist .)
    ELSE            reduce using rule 46 (varlist -> varlist COMMA varlist .)
    COMMA           shift and go to state 43

  ! COMMA           [ reduce using rule 46 (varlist -> varlist COMMA varlist .) ]


state 72

    (49) expr_list -> expr_list COMMA a_expr .
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

    COMMA           reduce using rule 49 (expr_list -> expr_list COMMA a_expr .)
    SEMICOLON       reduce using rule 49 (expr_list -> expr_list COMMA a_expr .)
    UNTIL           reduce using rule 49 (expr_list -> expr_list COMMA a_expr .)
    END             reduce using rule 49 (expr_list -> expr_list COMMA a_expr .)
    ELSE            reduce using rule 49 (expr_list -> expr_list COMMA a_expr .)
    ADD             shift and go to state 46
    SUB             shift and go to state 47
    MUL             shift and go to state 48
    DIV             shift and go to state 49

    a_op                           shift and go to state 45

state 73

    (22) a_expr -> a_expr a_op a_expr .
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    COMMA           reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    SEMICOLON       reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    UNTIL           reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    END             reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    ELSE            reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    BEGIN           reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    OR              reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    AND             reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    LT              reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    GT              reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    LEQ             reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    GEQ             reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    EQ              reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    NEQ             reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    THEN            reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    RBRACK          reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    RPAREN          reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    COLON           reduce using rule 22 (a_expr -> a_expr a_op a_expr .)
    ADD             shift and go to state 46
    SUB             shift and go to state 47
    MUL             shift and go to state 48
    DIV             shift and go to state 49

  ! ADD             [ reduce using rule 22 (a_expr -> a_expr a_op a_expr .) ]
  ! SUB             [ reduce using rule 22 (a_expr -> a_expr a_op a_expr .) ]
  ! MUL             [ reduce using rule 22 (a_expr -> a_expr a_op a_expr .) ]
  ! DIV             [ reduce using rule 22 (a_expr -> a_expr a_op a_expr .) ]

    a_op                           shift and go to state 45

state 74

    (27) a_expr -> LPAREN a_expr RPAREN .

    ADD             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    SUB             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    MUL             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    DIV             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    COMMA           reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    SEMICOLON       reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    UNTIL           reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    END             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    ELSE            reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    BEGIN           reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    OR              reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    AND             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    LT              reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    GT              reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    LEQ             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    GEQ             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    EQ              reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    NEQ             reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    THEN            reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    RBRACK          reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    RPAREN          reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)
    COLON           reduce using rule 27 (a_expr -> LPAREN a_expr RPAREN .)


state 75

    (35) l_expr -> l_expr l_op l_expr .
    (35) l_expr -> l_expr . l_op l_expr
    (36) l_expr -> l_expr . oprel a_expr
    (38) l_op -> . OR
    (39) l_op -> . AND
    (40) oprel -> . LT
    (41) oprel -> . GT
    (42) oprel -> . LEQ
    (43) oprel -> . GEQ
    (44) oprel -> . EQ
    (45) oprel -> . NEQ

  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
    BEGIN           reduce using rule 35 (l_expr -> l_expr l_op l_expr .)
    THEN            reduce using rule 35 (l_expr -> l_expr l_op l_expr .)
    SEMICOLON       reduce using rule 35 (l_expr -> l_expr l_op l_expr .)
    UNTIL           reduce using rule 35 (l_expr -> l_expr l_op l_expr .)
    END             reduce using rule 35 (l_expr -> l_expr l_op l_expr .)
    ELSE            reduce using rule 35 (l_expr -> l_expr l_op l_expr .)
    RPAREN          reduce using rule 35 (l_expr -> l_expr l_op l_expr .)
    OR              shift and go to state 55
    AND             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    LEQ             shift and go to state 59
    GEQ             shift and go to state 60
    EQ              shift and go to state 61
    NEQ             shift and go to state 62

  ! OR              [ reduce using rule 35 (l_expr -> l_expr l_op l_expr .) ]
  ! AND             [ reduce using rule 35 (l_expr -> l_expr l_op l_expr .) ]
  ! LT              [ reduce using rule 35 (l_expr -> l_expr l_op l_expr .) ]
  ! GT              [ reduce using rule 35 (l_expr -> l_expr l_op l_expr .) ]
  ! LEQ             [ reduce using rule 35 (l_expr -> l_expr l_op l_expr .) ]
  ! GEQ             [ reduce using rule 35 (l_expr -> l_expr l_op l_expr .) ]
  ! EQ              [ reduce using rule 35 (l_expr -> l_expr l_op l_expr .) ]
  ! NEQ             [ reduce using rule 35 (l_expr -> l_expr l_op l_expr .) ]

    l_op                           shift and go to state 53
    oprel                          shift and go to state 54

state 76

    (36) l_expr -> l_expr oprel a_expr .
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

    BEGIN           reduce using rule 36 (l_expr -> l_expr oprel a_expr .)
    OR              reduce using rule 36 (l_expr -> l_expr oprel a_expr .)
    AND             reduce using rule 36 (l_expr -> l_expr oprel a_expr .)
    LT              reduce using rule 36 (l_expr -> l_expr oprel a_expr .)
    GT              reduce using rule 36 (l_expr -> l_expr oprel a_expr .)
    LEQ             reduce using rule 36 (l_expr -> l_expr oprel a_expr .)
    GEQ             reduce using rule 36 (l_expr -> l_expr oprel a_expr .)
    EQ              reduce using rule 36 (l_expr -> l_expr oprel a_expr .)
    NEQ             reduce using rule 36 (l_expr -> l_expr oprel a_expr .)
    THEN            reduce using rule 36 (l_expr -> l_expr oprel a_expr .)
    SEMICOLON       reduce using rule 36 (l_expr -> l_expr oprel a_expr .)
    UNTIL           reduce using rule 36 (l_expr -> l_expr oprel a_expr .)
    END             reduce using rule 36 (l_expr -> l_expr oprel a_expr .)
    ELSE            reduce using rule 36 (l_expr -> l_expr oprel a_expr .)
    RPAREN          reduce using rule 36 (l_expr -> l_expr oprel a_expr .)
    ADD             shift and go to state 46
    SUB             shift and go to state 47
    MUL             shift and go to state 48
    DIV             shift and go to state 49

    a_op                           shift and go to state 45

state 77

    (34) l_expr -> LPAREN l_expr RPAREN .

    BEGIN           reduce using rule 34 (l_expr -> LPAREN l_expr RPAREN .)
    OR              reduce using rule 34 (l_expr -> LPAREN l_expr RPAREN .)
    AND             reduce using rule 34 (l_expr -> LPAREN l_expr RPAREN .)
    LT              reduce using rule 34 (l_expr -> LPAREN l_expr RPAREN .)
    GT              reduce using rule 34 (l_expr -> LPAREN l_expr RPAREN .)
    LEQ             reduce using rule 34 (l_expr -> LPAREN l_expr RPAREN .)
    GEQ             reduce using rule 34 (l_expr -> LPAREN l_expr RPAREN .)
    EQ              reduce using rule 34 (l_expr -> LPAREN l_expr RPAREN .)
    NEQ             reduce using rule 34 (l_expr -> LPAREN l_expr RPAREN .)
    THEN            reduce using rule 34 (l_expr -> LPAREN l_expr RPAREN .)
    SEMICOLON       reduce using rule 34 (l_expr -> LPAREN l_expr RPAREN .)
    UNTIL           reduce using rule 34 (l_expr -> LPAREN l_expr RPAREN .)
    END             reduce using rule 34 (l_expr -> LPAREN l_expr RPAREN .)
    ELSE            reduce using rule 34 (l_expr -> LPAREN l_expr RPAREN .)
    RPAREN          reduce using rule 34 (l_expr -> LPAREN l_expr RPAREN .)


state 78

    (16) repeat -> REPEAT stmt_list UNTIL l_expr .
    (35) l_expr -> l_expr . l_op l_expr
    (36) l_expr -> l_expr . oprel a_expr
    (38) l_op -> . OR
    (39) l_op -> . AND
    (40) oprel -> . LT
    (41) oprel -> . GT
    (42) oprel -> . LEQ
    (43) oprel -> . GEQ
    (44) oprel -> . EQ
    (45) oprel -> . NEQ

    SEMICOLON       reduce using rule 16 (repeat -> REPEAT stmt_list UNTIL l_expr .)
    UNTIL           reduce using rule 16 (repeat -> REPEAT stmt_list UNTIL l_expr .)
    END             reduce using rule 16 (repeat -> REPEAT stmt_list UNTIL l_expr .)
    ELSE            reduce using rule 16 (repeat -> REPEAT stmt_list UNTIL l_expr .)
    OR              shift and go to state 55
    AND             shift and go to state 56
    LT              shift and go to state 57
    GT              shift and go to state 58
    LEQ             shift and go to state 59
    GEQ             shift and go to state 60
    EQ              shift and go to state 61
    NEQ             shift and go to state 62

    l_op                           shift and go to state 53
    oprel                          shift and go to state 54

state 79

    (18) foreach -> FOREACH ID IN LPAREN . a_expr COLON a_expr RPAREN stmt
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . NUM
    (25) a_expr -> . varref
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    SUB             shift and go to state 28
    NUM             shift and go to state 29
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    a_expr                         shift and go to state 81
    varref                         shift and go to state 30

state 80

    (19) if_stmt -> IF l_expr THEN stmt_list . else_stmt
    (2) stmt_list -> stmt_list . SEMICOLON stmt
    (20) else_stmt -> .
    (21) else_stmt -> . ELSE stmt

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       shift and go to state 66
    UNTIL           reduce using rule 20 (else_stmt -> .)
    END             reduce using rule 20 (else_stmt -> .)
    ELSE            shift and go to state 83

  ! SEMICOLON       [ reduce using rule 20 (else_stmt -> .) ]
  ! ELSE            [ reduce using rule 20 (else_stmt -> .) ]

    else_stmt                      shift and go to state 82

state 81

    (18) foreach -> FOREACH ID IN LPAREN a_expr . COLON a_expr RPAREN stmt
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

    COLON           shift and go to state 84
    ADD             shift and go to state 46
    SUB             shift and go to state 47
    MUL             shift and go to state 48
    DIV             shift and go to state 49

    a_op                           shift and go to state 45

state 82

    (19) if_stmt -> IF l_expr THEN stmt_list else_stmt .

    SEMICOLON       reduce using rule 19 (if_stmt -> IF l_expr THEN stmt_list else_stmt .)
    UNTIL           reduce using rule 19 (if_stmt -> IF l_expr THEN stmt_list else_stmt .)
    END             reduce using rule 19 (if_stmt -> IF l_expr THEN stmt_list else_stmt .)
    ELSE            reduce using rule 19 (if_stmt -> IF l_expr THEN stmt_list else_stmt .)


state 83

    (21) else_stmt -> ELSE . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list else_stmt
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt                           shift and go to state 85
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 84

    (18) foreach -> FOREACH ID IN LPAREN a_expr COLON . a_expr RPAREN stmt
    (22) a_expr -> . a_expr a_op a_expr
    (23) a_expr -> . SUB a_expr
    (24) a_expr -> . NUM
    (25) a_expr -> . varref
    (26) a_expr -> . LITERAL_STR
    (27) a_expr -> . LPAREN a_expr RPAREN
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    SUB             shift and go to state 28
    NUM             shift and go to state 29
    LITERAL_STR     shift and go to state 31
    LPAREN          shift and go to state 32
    ID              shift and go to state 19

    a_expr                         shift and go to state 86
    varref                         shift and go to state 30

state 85

    (21) else_stmt -> ELSE stmt .

    UNTIL           reduce using rule 21 (else_stmt -> ELSE stmt .)
    SEMICOLON       reduce using rule 21 (else_stmt -> ELSE stmt .)
    END             reduce using rule 21 (else_stmt -> ELSE stmt .)
    ELSE            reduce using rule 21 (else_stmt -> ELSE stmt .)


state 86

    (18) foreach -> FOREACH ID IN LPAREN a_expr COLON a_expr . RPAREN stmt
    (22) a_expr -> a_expr . a_op a_expr
    (28) a_op -> . ADD
    (29) a_op -> . SUB
    (30) a_op -> . MUL
    (31) a_op -> . DIV

    RPAREN          shift and go to state 87
    ADD             shift and go to state 46
    SUB             shift and go to state 47
    MUL             shift and go to state 48
    DIV             shift and go to state 49

    a_op                           shift and go to state 45

state 87

    (18) foreach -> FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN . stmt
    (4) stmt -> . assignment
    (5) stmt -> . read
    (6) stmt -> . write
    (7) stmt -> . while
    (8) stmt -> . repeat
    (9) stmt -> . block
    (10) stmt -> . foreach
    (11) stmt -> . if_stmt
    (12) assignment -> . varref ASSIGN l_expr
    (13) read -> . READ varlist
    (14) write -> . WRITE expr_list
    (15) while -> . WHILE l_expr block
    (16) repeat -> . REPEAT stmt_list UNTIL l_expr
    (17) block -> . BEGIN stmt_list END
    (18) foreach -> . FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt
    (19) if_stmt -> . IF l_expr THEN stmt_list else_stmt
    (32) varref -> . varref LBRACK a_expr RBRACK
    (33) varref -> . ID

    READ            shift and go to state 13
    WRITE           shift and go to state 14
    WHILE           shift and go to state 15
    REPEAT          shift and go to state 16
    BEGIN           shift and go to state 17
    FOREACH         shift and go to state 18
    IF              shift and go to state 20
    ID              shift and go to state 19

    stmt                           shift and go to state 88
    assignment                     shift and go to state 4
    read                           shift and go to state 5
    write                          shift and go to state 6
    while                          shift and go to state 7
    repeat                         shift and go to state 8
    block                          shift and go to state 9
    foreach                        shift and go to state 10
    if_stmt                        shift and go to state 11
    varref                         shift and go to state 12

state 88

    (18) foreach -> FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt .

    SEMICOLON       reduce using rule 18 (foreach -> FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt .)
    UNTIL           reduce using rule 18 (foreach -> FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt .)
    END             reduce using rule 18 (foreach -> FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt .)
    ELSE            reduce using rule 18 (foreach -> FOREACH ID IN LPAREN a_expr COLON a_expr RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ADD in state 50 resolved as shift
WARNING: shift/reduce conflict for SUB in state 50 resolved as shift
WARNING: shift/reduce conflict for MUL in state 50 resolved as shift
WARNING: shift/reduce conflict for DIV in state 50 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 64 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 71 resolved as shift
WARNING: shift/reduce conflict for ADD in state 73 resolved as shift
WARNING: shift/reduce conflict for SUB in state 73 resolved as shift
WARNING: shift/reduce conflict for MUL in state 73 resolved as shift
WARNING: shift/reduce conflict for DIV in state 73 resolved as shift
WARNING: shift/reduce conflict for OR in state 75 resolved as shift
WARNING: shift/reduce conflict for AND in state 75 resolved as shift
WARNING: shift/reduce conflict for LT in state 75 resolved as shift
WARNING: shift/reduce conflict for GT in state 75 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 75 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 75 resolved as shift
WARNING: shift/reduce conflict for EQ in state 75 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 75 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 80 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 80 resolved as shift
